    Section 2.14, Vertex Programs
    
    The conventional GL vertex transformation model described in sections 2.10
    through 2.13 is a configurable but essentially hard-wired sequence of
    per-vertex computations based on a canonical set of per-vertex parameters
    and vertex transformation related state such as transformation matrices,
    lighting parameters, and texture coordinate generation parameters.  The
    general success and utility of the conventional GL vertex transformation
    model reflects its basic correspondence to the typical vertex
    transformation requirements of 3D applications.

    However when the conventional GL vertex transformation model is not
    sufficient, the vertex program mode provides a substantially more flexible
    model for vertex transformation.  The vertex program mode permits
    applications to define their own vertex programs.

    A vertex program is a character string that specifies a sequence of
    operations to perform.  Vertex program instructions are typically
    4-component vector operations that operate on per-vertex attributes and
    program parameters.  Vertex programs execute on a per-vertex basis and
    operate on each vertex completely independently from any other vertices.
    Vertex programs execute a finite fixed sequence of instructions with no
    branching or looping.  Vertex programs execute without data hazards so
    results computed in one instruction can be used immediately afterwards.
    The result of a vertex program is a set of vertex result registers that
    becomes the set of transformed vertex attributes used during clipping and
    primitive assembly.

    Vertex programs are defined to operate only in RGBA mode.  The results of
    vertex program execution are undefined if the GL is in color index mode.


    Section 2.14.1,  Program Objects

    The GL provides one or more program targets, each identifying a portion of
    the GL that can be controlled through application-specified programs.  The
    program target for vertex programs is VERTEX_PROGRAM_ARB.  Each program
    target has an associated program object, called the current program
    object.  Each program target also has a default program object, which is
    initially the current program object.

    Each program object has an associated program string.  The command

      ProgramStringARB(enum target, enum format, sizei len, 
                       const void *string);

    updates the program string for the current program object for <target>.
    <format> describes the format of the program string, which must currently
    be PROGRAM_FORMAT_ASCII_ARB.  <string> is a pointer to the array of bytes
    representing the program string being loaded, which need not be
    null-terminated.  The length of the array is given by <len>.  If <string>
    is null-terminated, <len> should not include the terminator.

    When a program string is loaded, it is interpreted according to syntactic
    and semantic rules corresponding to the program target specified by
    <target>.  If a program violates the syntactic or semantic restrictions of
    the program target, ProgramStringARB generates the error
    INVALID_OPERATION.

    Additionally, ProgramString will update the program error position
    (PROGRAM_ERROR_POSITION_ARB) and error string (PROGRAM_ERROR_STRING_ARB).
    If a program fails to load, the value of the program error position is set
    to the ubyte offset into the specified program string indicating where the
    first program error was detected.  If the program fails to load because of
    a semantic restriction that is not detected until the program is fully
    scanned, the error position is set to the value of <len>.  If a program
    loads successfully, the error position is set to the value negative one.
    The implementation-dependent program error string contains one or more
    error or warning messages.  If a program loads succesfully, the error
    string may either contain warning messages or be empty.

    Each program object has an associated array of program local parameters.
    The number and type of program local parameters is target- and
    implementation-dependent.  For vertex programs, program local parameters
    are four-component floating-point vectors.  The number of vectors is given
    by the implementation-dependent constant MAX_PROGRAM_LOCAL_PARAMETERS_ARB,
    which must be at least 96.  The commands

      void ProgramLocalParameter4fARB(enum target, uint index,
                                      float x, float y, float z, float w);
      void ProgramLocalParameter4fvARB(enum target, uint index, 
                                       const float *params);
      void ProgramLocalParameter4dARB(enum target, uint index,
                                      double x, double y, double z, double w);
      void ProgramLocalParameter4dvARB(enum target, uint index, 
                                       const double *params);

    update the values of the program local parameter numbered <index>
    belonging to the program object currently bound to <target>.  For
    ProgramLocalParameter4fARB and ProgramLocalParameter4dARB, the four
    components of the parameter are updated with the values of <x>, <y>, <z>,
    and <w>, respectively.  For ProgramLocalParameter4fvARB and
    ProgramLocalParameter4dvARB, the four components of the parameter are
    updated with the array of four values pointed to by <params>.  The error
    INVALID_VALUE is generated if <index> is greater than or equal to the
    number of program local parameters supported by <target>.

    Additionally, each program target has an associated array of program
    environment parameters.  Unlike program local parameters, program
    environment parameters are shared by all program objects of a given
    target.  The number and type of program environment parameters is target-
    and implementation-dependent.  For vertex programs, program environment
    parameters are four-component floating-point vectors.  The number of
    vectors is given by the implementation-dependent constant
    MAX_PROGRAM_ENV_PARAMETERS_ARB, which must be at least 96.  The commands

      void ProgramEnvParameter4fARB(enum target, uint index,
                                    float x, float y, float z, float w);
      void ProgramEnvParameter4fvARB(enum target, uint index,
                                     const float *params);
      void ProgramEnvParameter4dARB(enum target, uint index,
                                    double x, double y, double z, double w);
      void ProgramEnvParameter4dvARB(enum target, uint index,
                                     const double *params);

    update the values of the program environment parameter numbered <index>
    for the given program target <target>.  For ProgramEnvParameter4fARB and
    ProgramEnvParameter4dARB, the four components of the parameter are updated
    with the values of <x>, <y>, <z>, and <w>, respectively.  For
    ProgramEnvParameter4fvARB and ProgramEnvParameter4dvARB, the four
    components of the parameter are updated with the array of four values
    pointed to by <params>.  The error INVALID_VALUE is generated if <index>
    is greater than or equal to the number of program environment parameters
    supported by <target>.

    Each program target has a default program object.  Additionally, named
    program objects can be created and operated upon.  The name space for
    program objects is the positive integers and is shared by programs of all
    targets.  The name zero is reserved by the GL.

    A named program object is created by binding an unused program object name
    to a valid program target.  The binding is effected by calling

      BindProgramARB(enum target, uint program);

    with <target> set to the desired program target and <program> set to the
    unused program name.  The resulting program object has a program target
    given by <target> and is assigned target-specific default values (see
    section 2.14.7 for vertex programs).  BindProgramARB may also be used to
    bind an existing program object to a program target.  If <program> is
    zero, the default program object for <target> is bound.  If <program> is
    the name of an existing program object whose associated program target is
    <target>, the named program object is bound.  The error INVALID_OPERATION
    is generated if <program> names an existing program object whose
    associated program target is anything other than <target>.

    Programs objects are deleted by calling

      void DeleteProgramsARB(sizei n, const uint *programs);

    <programs> contains <n> names of programs to be deleted.  After a program
    object is deleted, its name is again unused.  If a program object that is
    bound to any target is deleted, it is as though BindProgramARB is first
    executed with same target and a <program> of zero.  Unused names in
    <programs> are silently ignored, as is the value zero.

    The command

      void GenProgramsARB(sizei n, uint *programs);

    returns <n> currently unused program names in <programs>.  These names are
    marked as used, for the purposes of GenProgramsARB only, but objects are
    created only when they are first bound using BindProgramARB.


    Section 2.14.2,  Vertex Program Grammar and Semantic Restrictions

    Vertex program strings are specified as an array of ASCII characters
    containing the program text.  When a vertex program is loaded by a call to
    ProgramStringARB, the program string is parsed into a set of tokens
    possibly separated by whitespace.  Spaces, tabs, newlines, carriage
    returns, and comments are considered whitespace.  Comments begin with the
    character "#" and are terminated by a newline, a carriage return, or the
    end of the program array.

    The Backus-Naur Form (BNF) grammar below specifies the syntactically valid
    sequences for vertex programs.  The set of valid tokens can be inferred
    from the grammar.  The token "" represents an empty string and is used to
    indicate optional rules.  A program is invalid if it contains any
    undefined tokens or characters.

    A vertex program is required to begin with the header string "!!ARBvp1.0",
    without any preceding whitespace.  This string identifies the subsequent
    program text as a vertex program (version 1.0) that should be parsed
    according to the following grammar and semantic rules.  Program string
    parsing begins with the character immediately following the header string.

    <program>              ::= <optionSequence> <statementSequence> "END"

    <optionSequence>       ::= <optionSequence> <option>
                             | ""

    <option>               ::= "OPTION" <identifier> ";"

    <statementSequence>    ::= <statementSequence> <statement>
                             | ""

    <statement>            ::= <instruction> ";"
                             | <namingStatement> ";"

    <instruction>          ::= <ARL_instruction>
                             | <VECTORop_instruction>
                             | <SCALARop_instruction>
                             | <BINSCop_instruction>
                             | <BINop_instruction>
                             | <TRIop_instruction>
                             | <SWZ_instruction>

    <ARL_instruction>      ::= "ARL" <maskedAddrReg> "," <scalarSrcReg>

    <VECTORop_instruction> ::= <VECTORop> <maskedDstReg> "," <swizzleSrcReg>

    <VECTORop>             ::= "ABS"
                             | "FLR"
                             | "FRC"
                             | "LIT"
                             | "MOV"

    <SCALARop_instruction> ::= <SCALARop> <maskedDstReg> "," <scalarSrcReg>

    <SCALARop>             ::= "EX2"
                             | "EXP"
                             | "LG2"
                             | "LOG"                          
                             | "RCP"
                             | "RSQ"

    <BINSCop_instruction>  ::= <BINSCop> <maskedDstReg> "," <scalarSrcReg> ","
                               <scalarSrcReg> 

    <BINSCop>              ::= "POW"
 
    <BINop_instruction>    ::= <BINop> <maskedDstReg> ","
                               <swizzleSrcReg> "," <swizzleSrcReg>

    <BINop>                ::= "ADD"
                             | "DP3"
                             | "DP4"
                             | "DPH"
                             | "DST"
                             | "MAX"
                             | "MIN"
                             | "MUL"
                             | "SGE"
                             | "SLT"
                             | "SUB"
                             | "XPD"

    <TRIop_instruction>    ::= <TRIop> <maskedDstReg> ","
                               <swizzleSrcReg> "," <swizzleSrcReg> ","
                               <swizzleSrcReg>

    <TRIop>                ::= "MAD"

    <SWZ_instruction>      ::= "SWZ" <maskedDstReg> "," <srcReg> "," 
                               <extendedSwizzle>

    <scalarSrcReg>         ::= <optionalSign> <srcReg> <scalarSuffix>

    <swizzleSrcReg>        ::= <optionalSign> <srcReg> <swizzleSuffix>

    <maskedDstReg>         ::= <dstReg> <optionalMask>

    <maskedAddrReg>        ::= <addrReg> <addrWriteMask>

    <extendedSwizzle>      ::= <extSwizComp> "," <extSwizComp> "," 
                                 <extSwizComp> "," <extSwizComp>

    <extSwizComp>          ::= <optionalSign> <extSwizSel>

    <extSwizSel>           ::= "0" 
                             | "1" 
                             | <component>

    <srcReg>               ::= <vertexAttribReg>
                             | <temporaryReg>
                             | <progParamReg>

    <dstReg>               ::= <temporaryReg>
                             | <vertexResultReg>

    <vertexAttribReg>      ::= <establishedName>
                             | <vtxAttribBinding>

    <temporaryReg>         ::= <establishedName>

    <progParamReg>         ::= <progParamSingle>
                             | <progParamArray> "[" <progParamArrayMem> "]"
                             | <paramSingleItemUse>

    <progParamSingle>      ::= <establishedName>

    <progParamArray>       ::= <establishedName>
    
    <progParamArrayMem>    ::= <progParamArrayAbs>
                             | <progParamArrayRel>
                             
    <progParamArrayAbs>    ::= <integer>

    <progParamArrayRel>    ::= <addrReg> <addrComponent> <addrRegRelOffset>

    <addrRegRelOffset>     ::= ""
                             | "+" <addrRegPosOffset>
                             | "-" <addrRegNegOffset>

    <addrRegPosOffset>     ::= <integer> from 0 to 63

    <addrRegNegOffset>     ::= <integer> from 0 to 64

    <vertexResultReg>      ::= <establishedName>
                             | <resultBinding>

    <addrReg>              ::= <establishedName>

    <addrComponent>        ::= "." "x"

    <addrWriteMask>        ::= "." "x"

    <scalarSuffix>         ::= "." <component>

    <swizzleSuffix>        ::= ""
                             | "." <component>
                             | "." <component> <component>
                                   <component> <component>

    <component>            ::= "x"
                             | "y"
                             | "z"
                             | "w"

    <optionalMask>         ::= ""
                             | "." "x"
                             | "." "y"
                             | "." "xy"
                             | "." "z"
                             | "." "xz"
                             | "." "yz"
                             | "." "xyz"
                             | "." "w"
                             | "." "xw"
                             | "." "yw"
                             | "." "xyw"
                             | "." "zw"
                             | "." "xzw"
                             | "." "yzw"
                             | "." "xyzw"

    <namingStatement>      ::= <ATTRIB_statement>
                             | <PARAM_statement>
                             | <TEMP_statement>
                             | <ADDRESS_statement>
                             | <OUTPUT_statement>
                             | <ALIAS_statement>

    <ATTRIB_statement>     ::= "ATTRIB" <establishName> "="
                                 <vtxAttribBinding>

    <vtxAttribBinding>     ::= "vertex" "." <vtxAttribItem>

    <vtxAttribItem>        ::= "position"
                             | "weight" <vtxOptWeightNum>
                             | "normal"
                             | "color" <optColorType>
                             | "fogcoord"
                             | "texcoord" <optTexCoordNum>
                             | "matrixindex" "[" <vtxWeightNum> "]"
                             | "attrib" "[" <vtxAttribNum> "]"

    <vtxAttribNum>         ::= <integer> from 0 to MAX_VERTEX_ATTRIBS_ARB-1

    <vtxOptWeightNum>      ::= ""
                             | "[" <vtxWeightNum> "]"

    <vtxWeightNum>         ::= <integer> from 0 to MAX_VERTEX_UNITS_ARB-1,
                                 must be divisible by four

    <PARAM_statement>      ::= <PARAM_singleStmt>
                             | <PARAM_multipleStmt>

    <PARAM_singleStmt>     ::= "PARAM" <establishName> <paramSingleInit>

    <PARAM_multipleStmt>   ::= "PARAM" <establishName> "[" <optArraySize> "]"
                                   <paramMultipleInit>

    <optArraySize>         ::= ""
                             | <integer> from 1 to MAX_PROGRAM_PARAMETERS_ARB
                                 (maximum number of allowed program 
                                  parameter bindings)

    <paramSingleInit>      ::= "=" <paramSingleItemDecl>

    <paramMultipleInit>    ::= "=" "{" <paramMultInitList> "}"

    <paramMultInitList>    ::= <paramMultipleItem>
                             | <paramMultipleItem> "," <paramMultiInitList>

    <paramSingleItemDecl>  ::= <stateSingleItem>
                             | <programSingleItem>
                             | <paramConstDecl>

    <paramSingleItemUse>   ::= <stateSingleItem>
                             | <programSingleItem>
                             | <paramConstUse>

    <paramMultipleItem>    ::= <stateMultipleItem>
                             | <programMultipleItem>
                             | <paramConstDecl>

    <stateMultipleItem>    ::= <stateSingleItem>
                             | "state" "." <stateMatrixRows>

    <stateSingleItem>      ::= "state" "." <stateMaterialItem>
                             | "state" "." <stateLightItem>
                             | "state" "." <stateLightModelItem>
                             | "state" "." <stateLightProdItem>
                             | "state" "." <stateTexGenItem>
                             | "state" "." <stateFogItem>
                             | "state" "." <stateClipPlaneItem>
                             | "state" "." <statePointItem>
                             | "state" "." <stateMatrixRow>

    <stateMaterialItem>    ::= "material" <optFaceType> "." <stateMatProperty>

    <stateMatProperty>     ::= "ambient"
                             | "diffuse"
                             | "specular"
                             | "emission"
                             | "shininess"

    <stateLightItem>       ::= "light" "[" <stateLightNumber> "]" "." 
                                 <stateLightProperty>

    <stateLightProperty>   ::= "ambient"
                             | "diffuse" 
                             | "specular"
                             | "position"
                             | "attenuation"
                             | "spot" "." <stateSpotProperty>
                             | "half"

    <stateSpotProperty>    ::= "direction" 

    <stateLightModelItem>  ::= "lightmodel" <stateLModProperty>

    <stateLModProperty>    ::= "." "ambient"
                             | <optFaceType> "." "scenecolor"

    <stateLightProdItem>   ::= "lightprod" "[" <stateLightNumber> "]" 
                                 <optFaceType> "." <stateLProdProperty>

    <stateLProdProperty>   ::= "ambient"
                             | "diffuse"
                             | "specular"

    <stateLightNumber>     ::= <integer> from 0 to MAX_LIGHTS-1

    <stateTexGenItem>      ::= "texgen" <optTexCoordNum> "." 
                                 <stateTexGenType> "." <stateTexGenCoord>

    <stateTexGenType>      ::= "eye"
                             | "object"

    <stateTexGenCoord>     ::= "s" 
                             | "t" 
                             | "r" 
                             | "q"

    <stateFogItem>         ::= "fog" "." <stateFogProperty>

    <stateFogProperty>     ::= "color" 
                             | "params" 

    <stateClipPlaneItem>   ::= "clip" "[" <stateClipPlaneNum> "]" "." "plane"

    <stateClipPlaneNum>    ::= <integer> from 0 to MAX_CLIP_PLANES-1

    <statePointItem>       ::= "point" "." <statePointProperty>

    <statePointProperty>   ::= "size"
                             | "attenuation"

    <stateMatrixRow>       ::= <stateMatrixItem> "." "row" "[" 
                                  <stateMatrixRowNum> "]"

    <stateMatrixRows>      ::= <stateMatrixItem> <optMatrixRows>

    <optMatrixRows>        ::= ""
                             | "." "row" "[" <stateMatrixRowNum> ".." 
                                  <stateMatrixRowNum> "]"

    <stateMatrixItem>      ::= "matrix" "." <stateMatrixName> 
                               <stateOptMatModifier>

    <stateOptMatModifier>  ::= ""
                             | "." <stateMatModifier>

    <stateMatModifier>     ::= "inverse" 
                             | "transpose" 
                             | "invtrans"

    <stateMatrixRowNum>    ::= <integer> from 0 to 3

    <stateMatrixName>      ::= "modelview" <stateOptModMatNum>
                             | "projection"
                             | "mvp"
                             | "texture" <optTexCoordNum>
                             | "palette" "[" <statePaletteMatNum> "]"
                             | "program" "[" <stateProgramMatNum> "]"
                             
    <stateOptModMatNum>    ::= ""
                             | "[" <stateModMatNum> "]"

    <stateModMatNum>       ::= <integer> from 0 to MAX_VERTEX_UNITS_ARB-1

    <statePaletteMatNum>   ::= <integer> from 0 to MAX_PALETTE_MATRICES_ARB-1

    <stateProgramMatNum>   ::= <integer> from 0 to MAX_PROGRAM_MATRICES_ARB-1

    <programSingleItem>    ::= <progEnvParam>
                             | <progLocalParam>

    <programMultipleItem>  ::= <progEnvParams>
                             | <progLocalParams>

    <progEnvParams>        ::= "program" "." "env" 
                                 "[" <progEnvParamNums> "]"

    <progEnvParamNums>     ::= <progEnvParamNum>
                             | <progEnvParamNum> ".." <progEnvParamNum>

    <progEnvParam>         ::= "program" "." "env" 
                                 "[" <progEnvParamNum> "]"

    <progLocalParams>      ::= "program" "." "local" 
                                 "[" <progLocalParamNums> "]"

    <progLocalParamNums>   ::= <progLocalParamNum>
                             | <progLocalParamNum> ".." <progLocalParamNum>

    <progLocalParam>       ::= "program" "." "local" 
                                 "[" <progLocalParamNum> "]"

    <progEnvParamNum>      ::= <integer> from 0 to
                               MAX_PROGRAM_ENV_PARAMETERS_ARB - 1

    <progLocalParamNum>    ::= <integer> from 0 to
                               MAX_PROGRAM_LOCAL_PARAMETERS_ARB - 1

    <paramConstDecl>       ::= <paramConstScalarDecl>
                             | <paramConstVector>

    <paramConstUse>        ::= <paramConstScalarUse>
                             | <paramConstVector>

    <paramConstScalarDecl> ::= <signedFloatConstant>

    <paramConstScalarUse>  ::= <floatConstant>

    <paramConstVector>     ::= "{" <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> ","
                                   <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> ","
                                   <signedFloatConstant> "," 
                                   <signedFloatConstant> "}"

    <signedFloatConstant>  ::= <optionalSign> <floatConstant>

    <floatConstant>        ::= see text

    <optionalSign>         ::= ""
                             | "-"
                             | "+"

    <TEMP_statement>       ::= "TEMP" <varNameList>

    <ADDRESS_statement>    ::= "ADDRESS" <varNameList>

    <varNameList>          ::= <establishName>
                             | <establishName> "," <varNameList>

    <OUTPUT_statement>     ::= "OUTPUT" <establishName> "="
                                 <resultBinding>

    <resultBinding>        ::= "result" "." "position"
                             | "result" "." <resultColBinding>
                             | "result" "." "fogcoord"
                             | "result" "." "pointsize"
                             | "result" "." "texcoord" <optTexCoordNum>

    <resultColBinding>     ::= "color" <optFaceType> <optColorType>

    <optFaceType>          ::= ""
                             | "." "front"
                             | "." "back"

    <optColorType>         ::= ""
                             | "." "primary"
                             | "." "secondary"

    <optTexCoordNum>       ::= ""
                             | "[" <texCoordNum> "]"

    <texCoordNum>          ::= <integer> from 0 to MAX_TEXTURE_UNITS-1

    <ALIAS_statement>      ::= "ALIAS" <establishName> "="
                                 <establishedName>

    <establishName>        ::= <identifier>

    <establishedName>      ::= <identifier>

    <identifier>           ::= see text

    The <integer> rule matches an integer constant.  The integer consists
    of a sequence of one or more digits ("0" through "9").

    The <floatConstant> rule matches a floating-point constant consisting
    of an integer part, a decimal point, a fraction part, an "e" or
    "E", and an optionally signed integer exponent.  The integer and
    fraction parts both consist of a sequence of one or more digits ("0"
    through "9").  Either the integer part or the fraction parts (not
    both) may be missing; either the decimal point or the "e" (or "E")
    and the exponent (not both) may be missing.

    The <identifier> rule matches a sequence of one or more letters ("A"
    through "Z", "a" through "z"), digits ("0" through "9), underscores ("_"),
    or dollar signs ("$"); the first character must not be a number.  Upper
    and lower case letters are considered different (names are
    case-sensitive).  The following strings are reserved keywords and may not
    be used as identifiers:

        ABS, ADD, ADDRESS, ALIAS, ARL, ATTRIB, DP3, DP4, DPH, DST, END, EX2,
        EXP, FLR, FRC, LG2, LIT, LOG, MAD, MAX, MIN, MOV, MUL, OPTION, OUTPUT,
        PARAM, POW, RCP, RSQ, SGE, SLT, SUB, SWZ, TEMP, XPD, program, result,
        state, and vertex.

    The error INVALID_OPERATION is generated if a vertex program fails to load
    because it is not syntactically correct or for one of the semantic
    restrictions described in the following sections.

    A successfully loaded vertex program is parsed into a sequence of
    instructions.  Each instruction is identified by its tokenized name.  The
    operation of these instructions when executed is defined in section
    2.14.5.  A successfully loaded program string replaces the program string
    previously loaded into the specified program object.  If the OUT_OF_MEMORY
    error is generated by ProgramStringARB, no change is made to the previous
    contents of the current program object.


    Section 2.14.3,  Vertex Program Variables

    Vertex programs may access a number of different variables during their
    execution.  The following sections define the variables that can be
    declared and used by a vertex program.

    Explicit variable declarations allow a vertex program to establish a
    variable name that can be used to refer to a specified resource in
    subsequent instructions.  A vertex program will fail to load if it
    declares the same variable name more than once or if it refers to a
    variable name that has not been previously declared in the program string.

    Implicit variable declarations allow a vertex program to use the name of
    certain available resources by name.

    Section 2.14.3.1,  Vertex Attributes

    Vertex program attribute variables are a set of four-component
    floating-point vectors holding the attributes of the vertex being
    processed.  Vertex attribute variables are read-only during vertex program
    execution.

    Vertex attribute variables can be declared explicitly using the
    <ATTRIB_statement> grammar rule, or implicitly using the
    <vtxAttribBinding> grammar rule in an executable instruction.

    Each vertex attribute variable is bound to a single item of vertex state
    according to the <vtxAttrBinding> grammar rule.  The set of GL state that
    can be bound to a vertex attribute variable is given in Table X.2.  Vertex
    attribute variables are initialized at each vertex program invocation with
    the current values of the bound state.

      Vertex Attribute Binding  Components  Underlying State
      ------------------------  ----------  ------------------------------
      vertex.position           (x,y,z,w)   object coordinates
      vertex.weight             (w,w,w,w)   vertex weights 0-3
      vertex.weight[n]          (w,w,w,w)   vertex weights n-n+3
      vertex.normal             (x,y,z,1)   normal
      vertex.color              (r,g,b,a)   primary color
      vertex.color.primary      (r,g,b,a)   primary color
      vertex.color.secondary    (r,g,b,a)   secondary color
      vertex.fogcoord           (f,0,0,1)   fog coordinate
      vertex.texcoord           (s,t,r,q)   texture coordinate, unit 0
      vertex.texcoord[n]        (s,t,r,q)   texture coordinate, unit n
      vertex.matrixindex        (i,i,i,i)   vertex matrix indices 0-3
      vertex.matrixindex[n]     (i,i,i,i)   vertex matrix indices n-n+3
      vertex.attrib[n]          (x,y,z,w)   generic vertex attribute n

      Table X.2:  Vertex Attribute Bindings.  The "Components" column
      indicates the mapping of the state in the "Underlying State" column.
      Values of "0" or "1" in the "Components" column indicate the constants
      0.0 and 1.0, respectively.  Bindings containing "[n]" require an integer
      value of <n> to select an individual item.

    If a vertex attribute binding matches "vertex.position", the "x", "y", "z"
    and "w" components of the vertex attribute variable are filled with the
    "x", "y", "z", and "w" components, respectively, of the vertex position.

    If a vertex attribute binding matches "vertex.normal", the "x", "y", and
    "z" components of the vertex attribute variable are filled with the "x",
    "y", and "z" components, respectively, of the vertex normal.  The "w"
    component is filled with 1.

    If a vertex attribute binding matches "vertex.color" or
    "vertex.color.primary", the "x", "y", "z", and "w" components of the
    vertex attribute variable are filled with the "r", "g", "b", and "a"
    components, respectively, of the vertex color.

    If a vertex attribute binding matches "vertex.color.secondary", the "x",
    "y", "z", and "w" components of the vertex attribute variable are filled
    with the "r", "g", "b", and "a" components, respectively, of the vertex
    secondary color.

    If a vertex attribute binding matches "vertex.fogcoord", the "x" component
    of the vertex attribute variable is filled with the vertex fog coordinate.
    The "y", "z", and "w" coordinates are filled with 0, 0, and 1,
    respectively.

    If a vertex attribute binding matches "vertex.texcoord" or
    "vertex.texcoord[n]", the "x", "y", "z", and "w" components of the vertex
    attribute variable are filled with the "s", "t", "r", and "q" components,
    respectively, of the vertex texture coordinates for texture unit <n>.  If
    "[n]" is omitted, texture unit zero is used.

    If a vertex attribute binding matches "vertex.weight" or
    "vertex.weight[n]", the "x", "y", "z", and "w" components of the vertex
    attribute variable are filled with vertex weights <n> through <n>+3,
    respectively.  If "[n]" is omitted, weights zero through three are used.
    For the purposes of this binding, all weights supported by the
    implementation but not set by the application are set to zero, including
    the extra derived weight corresponding to the fixed-function
    WEIGHT_SUM_UNITY_ARB enable.  For components whose corresponding weight is
    not supported by the implementation (i.e., numbered MAX_VERTEX_UNITS_ARB
    or larger), "y" and "z" components are set to 0.0 and "w" components are
    set to 1.0.  A vertex program will fail to load if a vertex attribute
    binding specifies a weight number <n> that is greater than or equal to
    MAX_VERTEX_UNITS_ARB or is not divisible by four.

    If a vertex attribute binding matches "vertex.matrixindex" or
    "vertex.matrixindex[n]", the "x", "y", "z", and "w" components of the
    vertex attribute variable are filled with matrix indices <n> through <n>+3
    of the vertex, respectively.  If "[n]" is omitted, matrix indices zero
    through three are used.  For components whose corresponding matrix index
    is not supported by the implementation (i.e., numbered
    MAX_VERTEX_UNITS_ARB or larger), "y", and "z" components are set to 0.0
    and "w" components are set to 1.0.  A vertex program will fail to load if
    an attribute binding specifies a matrix index number <n> that is greater
    than or equal MAX_VERTEX_UNITS_ARB or is not divisible by four.

    If a vertex attribute binding matches "vertex.attrib[n]", the "x", "y",
    "z" and "w" components of the vertex attribute variable are filled with
    the "x", "y", "z", and "w" components, respectively, of generic vertex
    attribute <n>.  Note that "vertex.attrib[0]" and "vertex.position" are
    equivalent.

    As described in section 2.7, setting a generic vertex attribute may leave
    a corresponding conventional vertex attribute undefined, and vice versa.
    To prevent inadvertent use of attribute pairs with undefined attributes, a
    vertex program will fail to load if it binds both a conventional vertex
    attribute and a generic vertex attribute listed in the same row of Table
    X.2.1.

      Conventional Attribute Binding      Generic Attribute Binding
      ------------------------------      -------------------------
      vertex.position                     vertex.attrib[0]
      vertex.weight                       vertex.attrib[1]
      vertex.weight[0]                    vertex.attrib[1]
      vertex.normal                       vertex.attrib[2]
      vertex.color                        vertex.attrib[3]
      vertex.color.primary                vertex.attrib[3]
      vertex.color.secondary              vertex.attrib[4]        
      vertex.fogcoord                     vertex.attrib[5]
      vertex.texcoord                     vertex.attrib[8]
      vertex.texcoord[0]                  vertex.attrib[8]
      vertex.texcoord[1]                  vertex.attrib[9]
      vertex.texcoord[2]                  vertex.attrib[10]
      vertex.texcoord[3]                  vertex.attrib[11]
      vertex.texcoord[4]                  vertex.attrib[12]
      vertex.texcoord[5]                  vertex.attrib[13]
      vertex.texcoord[6]                  vertex.attrib[14]
      vertex.texcoord[7]                  vertex.attrib[15]
      vertex.texcoord[n]                  vertex.attrib[8+n]

      Table X.2.1:  Invalid Vertex Attribute Binding Pairs.  Vertex programs
      may not bind both attributes listed in any row.  The <n> in the last row
      matches the number of any valid texture unit.


    Section 2.14.3.2,  Vertex Program Parameters

    Vertex program parameter variables are a set of four-component
    floating-point vectors used as constants during vertex program execution.
    Vertex program parameters retain their values across vertex program
    invocations, although their values can change between invocations due to
    GL state changes.

    Single program parameter variables and arrays of program parameter
    variables can be declared explicitly using the <PARAM_statement> grammar
    rule.  Single program parameter variables can also be declared implicitly
    using the <paramSingleItemUse> grammar rule in an executable instruction.

    Each single program parameter variable is bound to a constant vector or to
    a GL state vector according to the <paramSingleInit> grammar rule.
    Individual items of a program parameter array are bound to constant
    vectors or GL state vectors according to the <programMultipleInit> grammar
    rule.  The set of GL state that can be bound to program parameter
    variables are given in Tables X.3.1 through X.3.8.


    Constant Bindings

    A program parameter variable can be bound to a scalar or vector constant
    using the <paramConstDecl> grammar rule (explicit declarations) or the
    <paramConstUse> grammar rule (implicit declarations).  

    If a program parameter binding matches the <paramConstScalarDecl> or
    <paramConstScalarUse> grammar rules, the corresponding program parameter
    variable is bound to the vector (X,X,X,X), where X is the value of the
    specified constant.  Note that the <paramConstScalarUse> grammar rule,
    used only in implicit declarations, allows only non-negative constants.
    This disambiguates cases like "-2", which could conceivably be taken to
    mean either the vector "(2,2,2,2)" with all components negated or
    "(-2,-2,-2,-2)" without negation.  Only the former interpretation is
    allowed by the grammar.

    If a program parameter binding matches <paramConstVector>, the
    corresponding program parameter variable is bound to the vector (X,Y,Z,W),
    where X, Y, Z, and W are the values corresponding to the first, second,
    third, and fourth match of <signedFloatConstant>.  If fewer than four
    constants are specified, Y, Z, and W assume the values 0.0, 0.0, and 1.0,
    if their respective constants are not specified.

    Program parameter variables initialized to constant values can never be
    modified.


    Program Environment/Local Parameter Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      program.env[a]                 (x,y,z,w)   program environment 
                                                 parameter a
      program.local[a]               (x,y,z,w)   program local parameter a
      program.env[a..b]              (x,y,z,w)   program environment
                                                 parameters a through b
      program.local[a..b]            (x,y,z,w)   program local parameters
                                                 a through b

      Table X.3.1:  Program Environment/Local Parameter Bindings.  <a> and <b>
      indicate parameter numbers, where <a> must be less than or equal to <b>.

    If a program parameter binding matches "program.env[a]" or
    "program.local[a]", the four components of the program parameter variable
    are filled with the four components of program environment parameter <a>
    or program local parameter <a>, respectively.

    Additionally, for program parameter array bindings, "program.env[a..b]"
    and "program.local[a..b]" are equivalent to specifying program environment
    parameters <a> through <b> in order or program local parameters <a>
    through <b> in order, respectively.  In either case, a program will fail
    to load if <a> is greater than <b>.


    Material Property Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      state.material.ambient         (r,g,b,a)   front ambient material color
      state.material.diffuse         (r,g,b,a)   front diffuse material color
      state.material.specular        (r,g,b,a)   front specular material color
      state.material.emission        (r,g,b,a)   front emissive material color
      state.material.shininess       (s,0,0,1)   front material shininess
      state.material.front.ambient   (r,g,b,a)   front ambient material color
      state.material.front.diffuse   (r,g,b,a)   front diffuse material color
      state.material.front.specular  (r,g,b,a)   front specular material color
      state.material.front.emission  (r,g,b,a)   front emissive material color
      state.material.front.shininess (s,0,0,1)   front material shininess
      state.material.back.ambient    (r,g,b,a)   back ambient material color
      state.material.back.diffuse    (r,g,b,a)   back diffuse material color
      state.material.back.specular   (r,g,b,a)   back specular material color
      state.material.back.emission   (r,g,b,a)   back emissive material color
      state.material.back.shininess  (s,0,0,1)   back material shininess

      Table X.3.2:  Material Property Bindings.  If a material face is not
      specified in the binding, the front property is used.

    If a program parameter binding matches any of the material properties
    listed in Table X.3.2, the program parameter variable is filled according
    to the table.  For ambient, diffuse, specular, or emissive colors, the
    "x", "y", "z", and "w" components are filled with the "r", "g", "b", and
    "a" components, respectively, of the corresponding material color.  For
    material shininess, the "x" component is filled with the material's
    specular exponent, and the "y", "z", and "w" components are filled with 0,
    0, and 1, respectively.  Bindings containing ".back" refer to the back
    material; all other bindings refer to the front material.

    Material properties can be changed inside a Begin/End pair, either
    directly by calling Material, or indirectly through color material.
    However, such property changes are not guaranteed to update program
    parameter bindings until the following End command.  Program parameter
    variables bound to material properties changed inside a Begin/End pair are
    undefined until the following End command.


    Light Property Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      state.light[n].ambient         (r,g,b,a)   light n ambient color
      state.light[n].diffuse         (r,g,b,a)   light n diffuse color
      state.light[n].specular        (r,g,b,a)   light n specular color
      state.light[n].position        (x,y,z,w)   light n position
      state.light[n].attenuation     (a,b,c,e)   light n attenuation constants
                                                 and spot light exponent
      state.light[n].spot.direction  (x,y,z,c)   light n spot direction and
                                                 cutoff angle cosine
      state.light[n].half            (x,y,z,1)   light n infinite half-angle
      state.lightmodel.ambient       (r,g,b,a)   light model ambient color
      state.lightmodel.scenecolor    (r,g,b,a)   light model front scene color
      state.lightmodel.              (r,g,b,a)   light model front scene color
               front.scenecolor
      state.lightmodel.              (r,g,b,a)   light model back scene color
               back.scenecolor
      state.lightprod[n].ambient     (r,g,b,a)   light n / front material
                                                 ambient color product
      state.lightprod[n].diffuse     (r,g,b,a)   light n / front material
                                                 diffuse color product
      state.lightprod[n].specular    (r,g,b,a)   light n / front material
                                                 specular color product
      state.lightprod[n].            (r,g,b,a)   light n / front material
              front.ambient                      ambient color product
      state.lightprod[n].            (r,g,b,a)   light n / front material
              front.diffuse                      diffuse color product
      state.lightprod[n].            (r,g,b,a)   light n / front material
              front.specular                     specular color product
      state.lightprod[n].            (r,g,b,a)   light n / back material
              back.ambient                       ambient color product
      state.lightprod[n].            (r,g,b,a)   light n / back material
              back.diffuse                       diffuse color product
      state.lightprod[n].            (r,g,b,a)   light n / back material
              back.specular                      specular color product

      Table X.3.3: Light Property Bindings.  <n> indicates a light number.

    If a program parameter binding matches "state.light[n].ambient",
    "state.light[n].diffuse", or "state.light[n].specular", the "x", "y", "z",
    and "w" components of the program parameter variable are filled with the
    "r", "g", "b", and "a" components, respectively, of the corresponding
    light color.

    If a program parameter binding matches "state.light[n].position", the "x",
    "y", "z", and "w" components of the program parameter variable are filled
    with the "x", "y", "z", and "w" components, respectively, of the light
    position.
    
    If a program parameter binding matches "state.light[n].attenuation", the
    "x", "y", and "z" components of the program parameter variable are filled
    with the constant, linear, and quadratic attenuation parameters of the
    specified light, respectively (section 2.13.1).  The "w" component of the
    program parameter variable is filled with the spot light exponent of the
    specified light.

    If a program parameter binding matches "state.light[n].spot.direction",
    the "x", "y", and "z" components of the program parameter variable are
    filled with the "x", "y", and "z" components of the spot light direction
    of the specified light, respectively (section 2.13.1).  The "w" component
    of the program parameter variable is filled with the cosine of the spot
    light cutoff angle of the specified light.

    If a program parameter binding matches "state.light[n].half", the "x",
    "y", and "z" components of the program parameter variable are filled with
    the x, y, and z components, respectively, of the normalized infinite
    half-angle vector

      h_inf = || P + (0, 0, 1) ||.

    The "w" component is filled with 1.  In the computation of h_inf, P
    consists of the x, y, and z coordinates of the normalized vector from the
    eye position P_e to the eye-space light position P_pli (section 2.13.1).
    h_inf is defined to correspond to the normalized half-angle vector when
    using an infinite light (w coordinate of the position is zero) and an
    infinite viewer (v_bs is FALSE).  For local lights or a local viewer,
    h_inf is well-defined but does not match the normalized half-angle vector,
    which will vary depending on the vertex position.

    If a program parameter binding matches "state.lightmodel.ambient", the
    "x", "y", "z", and "w" components of the program parameter variable are
    filled with the "r", "g", "b", and "a" components of the light model
    ambient color, respectively.

    If a program parameter binding matches "state.lightmodel.scenecolor" or
    "state.lightmodel.front.scenecolor", the "x", "y", and "z" components of
    the program parameter variable are filled with the "r", "g", and "b"
    components respectively of the "front scene color"

      c_scene = a_cs * a_cm + e_cm,

    where a_cs is the light model ambient color, a_cm is the front ambient
    material color, and e_cm is the front emissive material color.  The "w"
    component of the program parameter variable is filled with the alpha
    component of the front diffuse material color.  If a program parameter
    binding matches "state.lightmodel.back.scenecolor", a similar back scene
    color, computed using back-facing material properties, is used.  The front
    and back scene colors match the values that would be assigned to vertices
    using conventional lighting if all lights were disabled.

    If a program parameter binding matches anything beginning with
    "state.lightprod[n]", the "x", "y", and "z" components of the program
    parameter variable are filled with the "r", "g", and "b" components,
    respectively, of the corresponding light product.  The three light product
    components are the products of the corresponding color components of the
    specified material property and the light color of the specified light
    (see Table X.3.3).  The "w" component of the program parameter variable is
    filled with the alpha component of the specified material property.

    Light products depend on material properties, which can be changed inside
    a Begin/End pair.  Such property changes are not guaranteed to take effect
    until the following End command.  Program parameter variables bound to
    light products whose corresponding material property changes inside a
    Begin/End pair are undefined until the following End command.


    Texture Coordinate Generation Property Bindings

      Binding                    Components  Underlying State
      -------------------------  ----------  ----------------------------
      state.texgen[n].eye.s      (a,b,c,d)   TexGen eye linear plane
                                             coefficients, s coord, unit n
      state.texgen[n].eye.t      (a,b,c,d)   TexGen eye linear plane
                                             coefficients, t coord, unit n
      state.texgen[n].eye.r      (a,b,c,d)   TexGen eye linear plane
                                             coefficients, r coord, unit n
      state.texgen[n].eye.q      (a,b,c,d)   TexGen eye linear plane
                                             coefficients, q coord, unit n
      state.texgen[n].object.s   (a,b,c,d)   TexGen object linear plane
                                             coefficients, s coord, unit n
      state.texgen[n].object.t   (a,b,c,d)   TexGen object linear plane
                                             coefficients, t coord, unit n
      state.texgen[n].object.r   (a,b,c,d)   TexGen object linear plane
                                             coefficients, r coord, unit n
      state.texgen[n].object.q   (a,b,c,d)   TexGen object linear plane
                                             coefficients, q coord, unit n

      Table X.3.4:  Texture Coordinate Generation Property Bindings.  "[n]" is
      optional -- texture unit <n> is used if specified; texture unit 0 is
      used otherwise.

    If a program parameter binding matches a set of TexGen plane coefficients,
    the "x", "y", "z", and "w" components of the program parameter variable
    are filled with the coefficients p1, p2, p3, and p4, respectively, for
    object linear coefficients, and the coefficents p1', p2', p3', and p4',
    respectively, for eye linear coefficients (section 2.10.4).


    Fog Property Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      state.fog.color                (r,g,b,a)   RGB fog color (section 3.10)
      state.fog.params               (d,s,e,r)   fog density, linear start
                                                 and end, and 1/(end-start)
                                                 (section 3.10) 

      Table X.3.5:  Fog Property Bindings

    If a program parameter binding matches "state.fog.color", the "x", "y",
    "z", and "w" components of the program parameter variable are filled with
    the "r", "g", "b", and "a" components, respectively, of the fog color
    (section 3.10).

    If a program parameter binding matches "state.fog.params", the "x", "y",
    and "z" components of the program parameter variable are filled with the
    fog density, linear fog start, and linear fog end parameters (section
    3.10), respectively.  The "w" component is filled with 1/(end-start),
    where end and start are the linear fog end and start parameters,
    respectively.


    Clip Plane Property Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      state.clip[n].plane            (a,b,c,d)   clip plane n coefficients

      Table X.3.6:  Clip Plane Property Bindings.  <n> specifies the clip
      plane number, and is required.

    If a program parameter binding matches "state.clip[n].plane", the "x",
    "y", "z", and "w" components of the program parameter variable are filled
    with the coefficients p1', p2', p3', and p4', respectively, of clip plane
    <n> (section 2.11).


    Point Property Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      state.point.size               (s,n,x,f)   point size, min and max size
                                                 clamps, and fade threshold
                                                 (section 3.3) 
      state.point.attenuation        (a,b,c,1)   point size attenuation consts

      Table X.3.7:  Point Property Bindings

    If a program parameter binding matches "state.point.size", the "x", "y",
    "z", and "w" components of the program parameter variable are filled with
    the point size, minimum point size, maximum point size, and fade
    threshold, respectively (section 3.3).

    If a program parameter binding matches "state.point.attenuation", the "x",
    "y", and "z" components of the program parameter variable are filled with
    the constant, linear, and quadratic point size attenuation parameters (a,
    b, and c), respectively (section 3.3).  The "w" component is filled with
    1.


    Matrix Property Bindings

      Binding                               Underlying State
      ------------------------------------  ---------------------------
      * state.matrix.modelview[n]           modelview matrix n
        state.matrix.projection             projection matrix
        state.matrix.mvp                    modelview-projection matrix
      * state.matrix.texture[n]             texture matrix n
        state.matrix.palette[n]             modelview palette matrix n
        state.matrix.program[n]             program matrix n

      Table X.3.8:  Base Matrix Property Bindings.  The "[n]" syntax indicates
      a specific matrix number.  For modelview and texture matrices, a matrix
      number is optional, and matrix zero will be used if the matrix number is
      omitted.  These base bindings may further be modified by a
      inverse/transpose selector and a row selector.

    If the beginning of a program parameter binding matches any of the matrix
    binding names listed in Table X.3.8, the binding corresponds to a 4x4
    matrix.  If the parameter binding is followed by ".inverse", ".transpose",
    or ".invtrans" (<stateMatModifier> grammar rule), the inverse, transpose,
    or transpose of the inverse, respectively, of the matrix specified in
    Table X.3.8 is selected.  Otherwise, the matrix specified in Table X.3.8
    is selected.  If the specified matrix is poorly-conditioned (singular or
    nearly so), its inverse matrix is undefined.  The binding name
    "state.matrix.mvp" refers to the product of modelview matrix zero and the
    projection matrix, defined as

       MVP = P * M0,

    where P is the projection matrix and M0 is modelview matrix zero.

    If the selected matrix is followed by ".row[<a>]" (matching the
    <stateMatrixRow> grammar rule), the "x", "y", "z", and "w" components of
    the program parameter variable are filled with the four entries of row <a>
    of the selected matrix.  In the example,

      PARAM m0 = state.matrix.modelview[1].row[0];
      PARAM m1 = state.matrix.projection.transpose.row[3];

    the variable "m0" is set to the first row (row 0) of modelview matrix 1
    and "m1" is set to the last row (row 3) of the transpose of the projection
    matrix.

    For program parameter array bindings, multiple rows of the selected matrix
    can be bound via the <stateMatrixRows> grammar rule.  If the selected
    matrix binding is followed by ".row[<a>..<b>]", the result is equivalent
    to specifying matrix rows <a> through <b>, in order.  A program will fail
    to load if <a> is greater than <b>.  If no row selection is specified
    (<optMatrixRows> matches ""), matrix rows 0 through 3 are bound in order.
    In the example,

      PARAM m2[] = { state.matrix.program[0].row[1..2] };
      PARAM m3[] = { state.matrix.program[0].transpose };

    the array "m2" has two entries, containing rows 1 and 2 of program matrix
    zero, and "m3" has four entries, containing all four rows of the transpose
    of program matrix zero.


    Program Parameter Arrays

    A program parameter array variable can be declared explicitly by matching
    the <PARAM_multipleStmt> grammar rule.  Programs can optionally specify
    the number of individual program parameters in the array, using the
    <optArraySize> grammar rule.  Program parameter arrays may not be declared
    implicity.

    Individual parameter variables in a program parameter array are bound to
    GL state vectors or constant vectors as specified by the grammar rule
    <paramMultInitList>.  Each individual parameter in the array is bound in
    turn as described above.  

    The total number of entries in the array is equal to the number of
    parameters bound in the initializer list.  A vertex program that specifies
    an array size (<optArraySize> matches <integer>) that does not match the
    number of parameter bindings in the initialization list will fail to load.

    Program parameter array variables may be accessed using absolute
    addressing by matching the <progParamArrayAbs> grammar rule, or relative
    addressing by matching the <progParamArrayRel> grammar rule.

    Array accesses using absolute addressing are checked against the limits of
    the array.  If any vertex program instruction accesses a program parameter
    array using absolute addressing with an out-of-range index (greater than
    or equal to the size of the array), the vertex program will fail to load.

    Individual state vectors can have no more than one unique binding in any
    given program.  The GL will automatically combine multiple bindings of the
    same state vector into a single unique binding, except for the case where
    a state vector is bound multiple times in program parameter arrays
    accessed using relative addressing.  A vertex program will fail to load if
    any GL state vector is bound multiple times in a single array accessed
    using relative addressing or bound once in two or more arrays accessed
    using relative addressing.


    Section 2.14.3.3,  Vertex Program Temporaries

    Vertex program temporary variables are a set of four-component
    floating-point vectors used to hold temporary results during vertex
    program execution.  Temporaries do not persist between program
    invocations, and are undefined at the beginning of each vertex program
    invocation.

    Vertex program temporary variables can be declared explicitly using the
    <TEMP_statement> grammar rule.  Each such statement can declare one or
    more temporaries.  Vertex program temporary variables can not be declared
    implicitly.


    Section 2.14.3.4,  Vertex Program Results

    Vertex program result variables are a set of four-component floating-point
    vectors used to hold the final results of a vertex program.  Vertex
    program result variables are write-only during vertex program execution.

    Vertex program result variables can be declared explicitly using the
    <OUTPUT_statement> grammar rule, or implicitly using the <resultBinding>
    grammar rule in an executable instruction.  Each vertex program result
    variable is bound to a transformed vertex attribute used during primitive
    assembly and rasterization.  The set of vertex program result variable
    bindings is given in Table X.4.

      Binding                        Components  Description
      -----------------------------  ----------  ----------------------------
      result.position                (x,y,z,w)   position in clip coordinates
      result.color                   (r,g,b,a)   front-facing primary color
      result.color.primary           (r,g,b,a)   front-facing primary color
      result.color.secondary         (r,g,b,a)   front-facing secondary color
      result.color.front             (r,g,b,a)   front-facing primary color
      result.color.front.primary     (r,g,b,a)   front-facing primary color
      result.color.front.secondary   (r,g,b,a)   front-facing secondary color
      result.color.back              (r,g,b,a)   back-facing primary color
      result.color.back.primary      (r,g,b,a)   back-facing primary color
      result.color.back.secondary    (r,g,b,a)   back-facing secondary color
      result.fogcoord                (f,*,*,*)   fog coordinate
      result.pointsize               (s,*,*,*)   point size
      result.texcoord                (s,t,r,q)   texture coordinate, unit 0
      result.texcoord[n]             (s,t,r,q)   texture coordinate, unit n

      Table X.4:  Vertex Result Variable Bindings.  Components labeled "*" are
      unused.

    If a result variable binding matches "result.position", updates to the
    "x", "y", "z", and "w" components of the result variable modify the "x",
    "y", "z", and "w" components, respectively, of the transformed vertex's
    clip coordinates.  Final window coordinates will be generated for the
    vertex as described in section 2.14.4.4.

    If a result variable binding match begins with "result.color", updates to
    the "x", "y", "z", and "w" components of the result variable modify the
    "r", "g", "b", and "a" components, respectively, of the corresponding
    vertex color attribute in Table X.4.  Color bindings that do not specify
    "front" or "back" are consided to refer to front-facing colors.  Color
    bindings that do not specify "primary" or "secondary" are considered to
    refer to primary colors.

    If a result variable binding matches "result.fogcoord", updates to the "x"
    component of the result variable set the transformed vertex's fog
    coordinate.  Updates to the "y", "z", and "w" components of the result
    variable have no effect.

    If a result variable binding matches "result.pointsize", updates to the
    "x" component of the result variable set the transformed vertex's point
    size.  Updates to the "y", "z", and "w" components of the result variable
    have no effect.

    If a result variable binding matches "result.texcoord" or
    "result.texcoord[n]", updates to the "x", "y", "z", and "w" components of
    the result variable set the "s", "t", "r" and "q" components,
    respectively, of the transformed vertex's texture coordinates for texture
    unit <n>.  If "[n]" is omitted, texture unit zero is selected.

    When in vertex program mode, all attributes of a transformed vertex are
    undefined at each vertex program invocation.  Any results, or even
    individual components of results, that are not written to during vertex
    program execution remain undefined.


    Section 2.14.3.5,  Vertex Program Address Registers

    Vertex program address register variables are a set of four-component
    signed integer vectors where only the "x" component of the address
    registers is currently accessible.  Address registers are used as indices
    when performing relative addressing in program parameter arrays (section
    2.14.4.2).

    Vertex program address registers can be declared explicitly using the
    <ADDRESS_statement> grammar rule.  Each such statement can declare one or
    more address registers.  Vertex program address registers can not be
    declared implicitly.

    Vertex program address register variables are undefined at each vertex
    program invocation.  Address registers can be written by the ARL
    instruction (section 2.14.5.3), and will be read when a program uses
    relative addressing in program parameter arrays.


    Section 2.14.3.6, Vertex Program Aliases

    Vertex programs can create aliases by matching the <ALIAS_statement>
    grammar rule.  Aliases allow programs to use multiple variable names to
    refer to a single underlying variable.  For example, the statement

      ALIAS var1 = var0

    establishes a variable name named "var1".  Subsequent references to "var1"
    in the program text are treated as references to "var0".  The left hand
    side of an ALIAS statement must be a new variable name, and the right hand
    side must be an established variable name.

    Aliases are not considered variable declarations, so do not count against
    the limits on the number of variable declarations allowed in the program
    text.


    Section 2.14.3.7, Vertex Program Resource Limits

    The vertex program execution environment provides implementation-dependent
    resource limits on the number of instructions, temporary variable
    declarations, vertex attribute bindings, address register declarations,
    and program parameter bindings.  A program that exceeds any of these
    resource limits will fail to load.  The resource limits for vertex
    programs can be queried by calling GetProgramiv (section 6.1.12) with a
    target of VERTEX_PROGRAM_ARB.

    The limit on vertex program instructions can be queried with a <pname> of
    MAX_PROGRAM_INSTRUCTIONS_ARB, and must be at least 128.  Each instruction
    in the program (matching the <instruction> grammar rule) counts against
    this limit.

    The limit on vertex program temporary variable declarations can be queried
    with a <pname> of MAX_PROGRAM_TEMPORARIES_ARB, and must be at least 12.
    Each temporary declared in the program, using the <TEMP_statement> grammar
    rule, counts against this limit.  Aliases of declared temporaries do not.
    
    The limit on vertex program attribute bindings can be queried with a
    <pname> of MAX_PROGRAM_ATTRIBS_ARB and must be at least 16.  Each distinct
    vertex attribute bound explicitly or implicitly in the program counts
    against this limit; vertex attributes bound multiple times count only
    once.

    The limit on vertex program address register declarations can be queried
    with a <pname> of MAX_PROGRAM_ADDRESS_REGISTERS_ARB, and must be at least
    1.  Each address register declared in the program, using the
    <ADDRESS_statement> grammar rule, counts against this limit.
    
    The limit on vertex program parameter bindings can be queried with a
    <pname> of MAX_PROGRAM_PARAMETERS_ARB, and must be at least 96.  Each
    distinct GL state vector bound explicitly or implicitly in the program
    counts against this limit; GL state vectors bound multiple times count
    only once.  Each constant vector bound to an array accessed using relative
    addressing counts against this limit, even if the same constant vector is
    bound multiple times or in multiple arrays.  Every other constant vector
    bound in the program is counted if and only if an identical constant
    vector has not already been counted.  Two constant vectors are considered
    identical if the four component values are numerically equivalent.  Recall
    that scalar constants bound in a program are treated as vector constants
    with the scalar value replicated.  In the following code

           PARAM arr1[4] = { {1,2,3,4}, {1,2,3,4}, {4,4,4,4}, {5,6,7,8} };
           PARAM arr2[3] = { {1,2,3,4}, {5,6,7,8}, {0,1,2,3} };
           PARAM x = {4,3,2,1};
           PARAM y = {1,2,3,4};
           PARAM z = 4;
           PARAM r = {4,3,2,1};

    assume that arr1 is accessed using relative addressing but arr2 is not.
    The four constants in arr1 all count against the limit.  Only two other
    constants, {0,1,2,3} in arr2, and {4,3,2,1} in x, are counted; the other
    constants are identical to constants that had been previously counted.

    In addition to the limits described above, the GL provides a similar set
    of implementation-dependent native resource limits.  These limits,
    specified in section 6.1.12, provide guidance as to whether the program is
    small enough to use a "native" mode where vertex programs may be executed
    with higher performance.  The native resource limits and usage counts are
    implementation-dependent and may not exactly correspond to limits and
    counts described above.  In particular, native resource consumption may be
    reduced by program optimizations performed by the GL, or increased due to
    emulation of non-native instructions.  Programs that satisfy the program
    resource limits described above, but whose native resource usage exceeds
    one or more native resource limits, are guaranteed to load but may execute
    suboptimally.

    To assist in resource counting, the GL additionally provides GetProgram
    queries to determine the resource usage and native resource usage of the
    currently bound program, and to determine whether the bound program
    exceeds any native resource limit.


    Section 2.14.4,  Vertex Program Execution Environment

    If vertex program mode is enabled, the currently bound vertex program is
    executed when a vertex is specified directly through the Vertex command,
    indirectly through vertex arrays or evaluators (section 5.1), or when the
    current raster position is updated.  

    If vertex program mode is enabled and the currently bound program object
    does not contain a valid vertex program, the error INVALID_OPERATION will
    be generated by Begin, RasterPos, and any command that implicitly calls
    Begin (e.g., DrawArrays).

    Vertex programs execute a sequence of instructions without
    branching.  Vertex programs begin by executing the first instruction in
    the program, and execute instructions in the order specified in the
    program until the last instruction is completed.
    
    There are twenty-seven vertex program instructions.  The instructions and
    their respective input and output parameters are summarized in Table X.5.

      Instruction    Inputs  Output   Description
      -----------    ------  ------   --------------------------------
      ABS            v       v        absolute value
      ADD            v,v     v        add
      ARL            s       a        address register load
      DP3            v,v     ssss     3-component dot product
      DP4            v,v     ssss     4-component dot product
      DPH            v,v     ssss     homogeneous dot product
      DST            v,v     v        distance vector
      EX2            s       ssss     exponential base 2
      EXP            s       v        exponential base 2 (approximate)
      FLR            v       v        floor
      FRC            v       v        fraction
      LG2            s       ssss     logarithm base 2
      LIT            v       v        compute light coefficients
      LOG            s       v        logarithm base 2 (approximate)
      MAD            v,v,v   v        multiply and add
      MAX            v,v     v        maximum
      MIN            v,v     v        minimum
      MOV            v       v        move
      MUL            v,v     v        multiply
      POW            s,s     ssss     exponentiate
      RCP            s       ssss     reciprocal
      RSQ            s       ssss     reciprocal square root
      SGE            v,v     v        set on greater than or equal
      SLT            v,v     v        set on less than
      SUB            v,v     v        subtract
      SWZ            v       v        extended swizzle
      XPD            v,v     v        cross product

      Table X.5:  Summary of vertex program instructions.  "v" indicates a
      floating-point vector input or output, "s" indicates a floating-point
      scalar input, "ssss" indicates a scalar output replicated across a
      4-component result vector, and "a" indicates a single address register
      component.


    Section 2.14.4.1, Vertex Program Operands

    Most vertex program instructions operate on floating-point vectors or
    scalars, as indicated by the grammar rules <swizzleSrcReg> and
    <scalarSrcReg>, respectively.

    Vector and scalar operands can be obtained from vertex attribute, program
    parameter, or temporary registers, as indicated by the <srcReg> rule.  For
    scalar operands, a single vector component is selected by the
    <scalarSuffix> rule, where the characters "x", "y", "z", and "w" select
    the x, y, z, and w components, respectively, of the vector.

    Vector operands can be swizzled according to the <swizzleSuffix> rule.  In
    its most general form, the <swizzleSuffix> rule matches the pattern
    ".????" where each question mark is replaced with one of "x", "y", "z", or
    "w".  For such patterns, the x, y, z, and w components of the operand are
    taken from the vector components named by the first, second, third, and
    fourth character of the pattern, respectively.  For example, if the
    swizzle suffix is ".yzzx" and the specified source contains {2,8,9,0}, the
    swizzled operand used by the instruction is {8,9,9,2}.

    If the <swizzleSuffix> rule matches "", it is treated as though it were
    ".xyzw".  If the <swizzleSuffix> rule matches (ignoring whitespace) ".x",
    ".y", ".z", or ".w", these are treated the same as ".xxxx", ".yyyy",
    ".zzzz", and ".wwww" respectively.

    Floating-point scalar or vector operands can optionally be negated
    according to the <optionalSign> rule in <scalarSrcReg> and
    <swizzleSrcReg>.  If the <optionalSign> matches "-", each operand or
    operand component is negated.

    The following pseudo-code spells out the operand generation process.  In
    the example, "float" is a floating-point scalar type, while "floatVec" is
    a four-component vector.  "source" refers to the register used for the
    operand, matching the <srcReg> rule.  "negate" is TRUE if the
    <optionalSign> rule in <scalarSrcReg> or <swizzleSrcReg> matches "-" and
    FALSE otherwise.  The ".c***", ".*c**", ".**c*", ".***c" modifiers refer
    to the x, y, z, and w components obtained by the swizzle operation; the
    ".c" modifier refers to the single component selected for a scalar load.

      floatVec VectorLoad(floatVec source)
      {
          floatVec operand;

          operand.x = source.c***;
          operand.y = source.*c**;
          operand.z = source.**c*;
          operand.w = source.***c;
          if (negate) {
             operand.x = -operand.x;
             operand.y = -operand.y;
             operand.z = -operand.z;
             operand.w = -operand.w;
          }

          return operand;
      }

      float ScalarLoad(floatVec source) 
      {
          float operand;

          operand = source.c;
          if (negate) {
            operand = -operand;
          }

          return operand;
      }

    Section 2.14.4.2,  Vertex Program Parameter Arrays

    A vertex program can load a single element of a program parameter array
    using either absolute or relative addressing.  Program parameter arrays
    are accessed when the <progParamArray> rule is matched.

    Absolute addressing is used when the <progParamArrayMem> grammar rule
    matches <progParamArrayAbs>.  When using absolute addressing, the offset
    of the selected entry in the array is given by the number matching
    <progParamRegNum>.

    Relative addressing is used when the <progParamArrayMem> grammar rule
    matches <progParamArrayRel>.  When using relative addressing, the offset
    of the selected entry in the array is computed by adding the address
    register component specified by the <addrReg> and <addrComponent> rules to
    the positive or negative offset specified by the <addrRegRelOffset> rule.
    If <addrRegRelOffset> matches "", no fixed offset is added to the address
    register component.  If the computed offset is negative or exceeds the
    size of the array, the results of the access are undefined, but may not
    lead to program or GL termination.

    The following pseudo-code spells out the process of loading a program
    parameter from an array.  "addrReg" refers to the address register
    component used for relative addressing, "absolute" is TRUE if the operand
    uses absolute addressing and FALSE otherwise.  "paramNumber" is the
    program parameter number for absolute addressing; "paramOffset" is the
    constant program parameter offset for relative addressing.  "paramArray"
    is the parameter array that matches the <progParamArray> rule.

      floatVec ProgramParameterLoad(int addrReg)
      {
        int index;
        
        if (absolute) {
          index = paramNumber;
        } else {
          index = addrReg + paramOffset
        }

        return paramArray[index];
      }

    Relative addressing can only be used for accessing program parameter
    arrays.


    Section 2.14.4.3,  Vertex Program Destination Register Update

    Most vertex program instructions write a 4-component result vector to a
    single temporary or vertex result register.  Writes to individual
    components of the destination register are controlled by individual
    component write masks specified as part of the instruction.

    The component write mask is specified by the <optionalMask> rule found in
    the <maskedDstReg> rule.  If the optional mask is "", all components are
    enabled.  Otherwise, the optional mask names the individual components to
    enable.  The characters "x", "y", "z", and "w" match the x, y, z, and w
    components respectively.  For example, an optional mask of ".xzw"
    indicates that the x, z, and w components should be enabled for writing
    but the y component should not.  The grammar requires that the destination
    register mask components must be listed in "xyzw" order.

    Each component of the destination register is updated with the result of
    the vertex program instruction if and only if the component is enabled for
    writes by the component write mask.  Otherwise, the component of the
    destination register remains unchanged.

    The following pseudocode illustrates the process of writing a result
    vector to the destination register.  In the pseudocode, "instrmask" refers
    to the component write mask given by the <optionalMask> rule.  "result"
    and "destination" refer to the result vector and the register selected by
    <dstReg>, respectively.

      void UpdateDestination(floatVec destination, floatVec result)
      {
          floatVec merged;

          // Merge the converted result into the destination register, under
          // control of the compile-time write mask.
          merged = destination;
          if (instrMask.x) {
              merged.x = result.x;
          }
          if (instrMask.y) {
              merged.y = result.y;
          }
          if (instrMask.z) {
              merged.z = result.z;
          }
          if (instrMask.w) {
              merged.w = result.w;
          }

          // Write out the new destination register.
          destination = merged;
      }

    The "ARL" instruction updates the single address register component
    similarly; the grammar is designed so that it writes to only the "x"
    component of an address register variable.


    Section 2.14.4.4,  Vertex Program Result Processing

    As a vertex program executes, it will write to one or more result
    registers that are mapped to transformed vertex attributes.  When a vertex
    program completes, the transformed vertex attributes are used to generate
    primitives.

    The clip coordinates written to "result.position" are used to generate
    normalized device coordinates and window coordinates for the vertex in the
    manner described section 2.10.

    Transformed vertices are then assembled into primitives and clipped as
    described in section 2.11.

    The selection between front-facing and back-facing color attributes
    depends on the primitive to which the vertex belongs.  If the primitive is
    a point or a line segment, or if vertex program two-sided color mode is
    disabled, the front-facing colors are always selected.  If it is a polygon
    and two-sided color mode is enabled, then the selection is performed in
    exactly the same way as in two-sided lighting mode (section 2.13.1).
    Vertex program two-sided color mode is enabled and disabled by calling
    Enable or Disable with the symbolic value VERTEX_PROGRAM_TWO_SIDE_ARB.

    Finally, as primitives are assembled, color clamping (section 2.13.6),
    flatshading (section 2.13.7), color, attribute clipping (section 2.13.8),
    and final color processing (section 2.13.9) operations are applied to the
    transformed vertices.


    Section 2.14.4.5,  Vertex Program Options

    The <optionSequence> grammar rule provides a mechanism for programs to
    indicate that one or more extended language features are used by the
    program.  All program options used by the program must be declared at the
    beginning of the program string.  Each program option specified in a
    program string will modify the syntactic or semantic rules used to
    interpet the program and the execution environment used to execute the
    program.  Program options not present in the program string are ignored,
    even if they are supported by the GL.

    The <identifier> token in the <option> rule must match the name of a
    program option supported by the implementation.  To avoid option name
    conflicts, option identifiers are required to begin with a vendor prefix.
    A program will fail to load if it specifies a program option not supported
    by the GL.

    Vertex program options should confine their semantic changes to the domain
    of vertex programs.  Support for a vertex program option should not change
    the specification and behavior of vertex programs not requesting use of
    that option.

    2.14.4.5.1,  Position-Invariant Vertex Program Option

    If a vertex program specifies the "ARB_position_invariant" option, the
    program is used to generate all transformed vertex attributes except for
    position.  Instead, clip coordinates are computed as specified in section
    2.10.  Additionally, user clipping is performed as described in section
    2.11.  Use of position-invariant vertex programs should generally
    guarantee that the transformed position of a vertex should be the same
    whether vertex program mode is enabled or disabled, allowing for correct
    mixed multi-pass rendering semantics.

    When the position-invariant option is specified in a vertex program,
    vertex programs can no longer produced a transformed position.  The
    <resultBinding> rule is modified to remove "result.position" from the list
    of token sequences matching the rule.  A semantic restriction is added to
    indicate that a vertex program will fail to load if the number of
    instructions it contains exceeds the implementation-dependent limit minus
    four.


    Section 2.14.5,  Vertex Program Instruction Set

    The following sections describe the set of supported vertex program
    instructions.  Each section contains pseudocode describing the
    instruction.  Instructions will have up to three operands, referred to as
    "op0", "op1", and "op2".  The operands are loaded using the mechanisms
    specified in section 2.14.4.1.  The variables "tmp", "tmp0", "tmp1", and
    "tmp2" describe scalars or vectors used to hold intermediate results in
    the instruction.  Most instructions will generate a result vector called
    "result".  The result vector is then written to the destination register
    specified in the instruction as described in section 2.14.4.3.


    Section 2.14.5.1,  ABS:  Absolute Value

    The ABS instruction performs a component-wise absolute value operation on
    the single operand to yield a result vector.

      tmp = VectorLoad(op0); 
      result.x = fabs(tmp.x);
      result.y = fabs(tmp.y);
      result.z = fabs(tmp.z);
      result.w = fabs(tmp.w);


    Section 2.14.5.2,  ADD:  Add

    The ADD instruction performs a component-wise add of the two operands to
    yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.x + tmp1.x;
      result.y = tmp0.y + tmp1.y;
      result.z = tmp0.z + tmp1.z;
      result.w = tmp0.w + tmp1.w;

    The following rules apply to addition:

      1. <x> + <y> == <y> + <x>, for all <x> and <y>.
      2. <x> + 0.0 == <x>, for all <x>.


    Section 2.14.5.3,  ARL:  Address Register Load

    The ARL instruction loads a single scalar operand and performs a floor
    operation to generate a signed integer scalar result:

        result = floor(ScalarLoad(op0));

    The floor operation returns the largest integer less than or equal to the
    operand.  For example floor(-1.7) = -2.0, floor(+1.0) = +1.0, and
    floor(+3.7) = +3.0.


    Section 2.14.5.4,  DP3:  Three-Component Dot Product

    The DP3 instruction computes a three-component dot product of the two
    operands (using the x, y, and z components) and replicates the dot product
    to all four components of the result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + 
            (tmp0.z * tmp1.z);
      result.x = dot;
      result.y = dot;
      result.z = dot;
      result.w = dot;


    Section 2.14.5.5,  DP4:  Four-Component Dot Product

    The DP4 instruction computes a four-component dot product of the two
    operands and replicates the dot product to all four components of the
    result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1):
      dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + 
            (tmp0.z * tmp1.z) + (tmp0.w * tmp1.w);
      result.x = dot;
      result.y = dot;
      result.z = dot;
      result.w = dot;


    Section 2.14.5.6,  DPH:  Homogeneous Dot Product

    The DPH instruction computes a three-component dot product of the two
    operands (using the x, y, and z components), adds the w component of the
    second operand, and replicates the sum to all four components of the
    result vector.  This is equivalent to a four-component dot product where
    the w component of the first operand is forced to 1.0.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1):
      dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + 
            (tmp0.z * tmp1.z) + tmp1.w;
      result.x = dot;
      result.y = dot;
      result.z = dot;
      result.w = dot;


    Section 2.14.5.7,  DST:  Distance Vector

    The DST instruction computes a distance vector from two specially-
    formatted operands.  The first operand should be of the form [NA, d^2,
    d^2, NA] and the second operand should be of the form [NA, 1/d, NA, 1/d],
    where NA values are not relevant to the calculation and d is a vector
    length.  If both vectors satisfy these conditions, the result vector will
    be of the form [1.0, d, d^2, 1/d].

    The exact behavior is specified in the following pseudo-code:

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = 1.0;
      result.y = tmp0.y * tmp1.y;
      result.z = tmp0.z;
      result.w = tmp1.w;

    Given an arbitrary vector, d^2 can be obtained using the DP3 instruction
    (using the same vector for both operands) and 1/d can be obtained from d^2
    using the RSQ instruction.

    This distance vector is useful for per-vertex light attenuation
    calculations:  a DP3 operation using the distance vector and an
    attenuation constants vector as operands will yield the attenuation
    factor.


    Section 2.14.5.8,  EX2:  Exponential Base 2

    The EX2 instruction approximates 2 raised to the power of the scalar
    operand and replicates the approximation to all four components of the
    result vector.

      tmp = ScalarLoad(op0);
      result.x = Approx2ToX(tmp);
      result.y = Approx2ToX(tmp);
      result.z = Approx2ToX(tmp);
      result.w = Approx2ToX(tmp);


    Section 2.14.5.9,  EXP:  Exponential Base 2 (approximate)

    The EXP instruction computes a rough approximation of 2 raised to the
    power of the scalar operand.  The approximation is returned in the "z"
    component of the result vector.  A vertex program can also use the "x" and
    "y" components of the result vector to generate a more accurate
    approximation by evaluating

        result.x * f(result.y),
    
    where f(x) is a user-defined function that approximates 2^x over the
    domain [0.0, 1.0).  The "w" component of the result vector is always 1.0.
    
    The exact behavior is specified in the following pseudo-code:

      tmp = ScalarLoad(op0);
      result.x = 2^floor(tmp);
      result.y = tmp - floor(tmp);
      result.z = RoughApprox2ToX(tmp);
      result.w = 1.0;

    The approximation function is accurate to at least 10 bits:

      | RoughApprox2ToX(x) - 2^x | < 1.0 / 2^11, if 0.0 <= x < 1.0,

    and, in general,
   
      | RoughApprox2ToX(x) - 2^x | < (1.0 / 2^11) * (2^floor(x)).


    Section 2.14.5.10,  FLR:  Floor

    The FLR instruction performs a component-wise floor operation on the
    operand to generate a result vector.  The floor of a value is defined as
    the largest integer less than or equal to the value.  The floor of 2.3 is
    2.0; the floor of -3.6 is -4.0.

      tmp = VectorLoad(op0);
      result.x = floor(tmp.x);
      result.y = floor(tmp.y);
      result.z = floor(tmp.z);
      result.w = floor(tmp.w);


    Section 2.14.5.11,  FRC:  Fraction

    The FRC instruction extracts the fractional portion of each component of
    the operand to generate a result vector.  The fractional portion of a
    component is defined as the result after subtracting off the floor of the
    component (see FLR), and is always in the range [0.0, 1.0).

    For negative values, the fractional portion is NOT the number written to
    the right of the decimal point -- the fractional portion of -1.7 is not
    0.7 -- it is 0.3.  0.3 is produced by subtracting the floor of -1.7 (-2.0)
    from -1.7.

      tmp = VectorLoad(op0);
      result.x = fraction(tmp.x);
      result.y = fraction(tmp.y);
      result.z = fraction(tmp.z);
      result.w = fraction(tmp.w);


    Section 2.14.5.12,  LG2:  Logarithm Base 2

    The LG2 instruction approximates the base 2 logarithm of the scalar
    operand and replicates it to all four components of the result vector.

      tmp = ScalarLoad(op0);
      result.x = ApproxLog2(tmp);
      result.y = ApproxLog2(tmp);
      result.z = ApproxLog2(tmp);
      result.w = ApproxLog2(tmp);

    If the scalar operand is zero or negative, the result is undefined.


    Section 2.14.5.13,  LIT:  Light Coefficients

    The LIT instruction accelerates per-vertex lighting by computing lighting
    coefficients for ambient, diffuse, and specular light contributions.  The
    "x" component of the single operand is assumed to hold a diffuse dot
    product (n dot VP_pli, as in the vertex lighting equations in Section
    2.13.1).  The "y" component of the operand is assumed to hold a specular
    dot product (n dot h_i).  The "w" component of the operand is assumed to
    hold the specular exponent of the material (s_rm), and is clamped to the
    range (-128, +128) exclusive.

    The "x" component of the result vector receives the value that should be
    multiplied by the ambient light/material product (always 1.0).  The "y"
    component of the result vector receives the value that should be
    multiplied by the diffuse light/material product (n dot VP_pli).  The "z"
    component of the result vector receives the value that should be
    multiplied by the specular light/material product (f_i * (n dot h_i) ^
    s_rm).  The "w" component of the result is the constant 1.0.

    Negative diffuse and specular dot products are clamped to 0.0, as is done
    in the standard per-vertex lighting operations.  In addition, if the
    diffuse dot product is zero or negative, the specular coefficient is
    forced to zero.

      tmp = VectorLoad(op0);
      if (tmp.x < 0) tmp.x = 0;
      if (tmp.y < 0) tmp.y = 0;
      if (tmp.w < -(128.0-epsilon)) tmp.w = -(128.0-epsilon);
      else if (tmp.w > 128-epsilon) tmp.w = 128-epsilon;
      result.x = 1.0;
      result.y = tmp.x;
      result.z = (tmp.x > 0) ? RoughApproxPower(tmp.y, tmp.w) : 0.0;
      result.w = 1.0;

    The exponentiation approximation function may be defined in terms of the
    base 2 exponentiation and logarithm approximation operations in the EXP
    and LOG instructions, where

      RoughApproxPower(a,b) = RoughApproxExp2(b * RoughApproxLog2(a)).

    In particular, the approximation may not be any more accurate than the
    underlying EXP and LOG operations.

    Also, since 0^0 is defined to be 1, RoughApproxPower(0.0, 0.0) will
    produce 1.0.


    Section 2.14.5.14,  LOG:  Logarithm Base 2 (approximate)

    The LOG instruction computes a rough approximation of the base 2 logarithm
    of the absolute value of the scalar operand.  The approximation is
    returned in the "z" component of the result vector.  A vertex program can
    also use the "x" and "y" components of the result vector to generate a
    more accurate approximation by evaluating

        result.x + f(result.y),
    
    where f(x) is a user-defined function that approximates 2^x over the
    domain [1.0, 2.0).  The "w" component of the result vector is always 1.0.

    The exact behavior is specified in the following pseudo-code:

      tmp = fabs(ScalarLoad(op0));
      result.x = floor(log2(tmp));
      result.y = tmp / 2^(floor(log2(tmp)));
      result.z = RoughApproxLog2(tmp);
      result.w = 1.0;
   
    Here, "floor(log2(tmp))" refers to the floor of the exact logarithm, which
    can be easily computed for standard floating-point representations.  The
    approximation function is accurate to at least 10 bits:

      | RoughApproxLog2(x) - log_2(x) | < 1.0 / 2^11.


    Section 2.14.5.15,  MAD:  Multiply and Add

    The MAD instruction performs a component-wise multiply of the first two
    operands, and then does a component-wise add of the product to the third
    operand to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      tmp2 = VectorLoad(op2);
      result.x = tmp0.x * tmp1.x + tmp2.x;
      result.y = tmp0.y * tmp1.y + tmp2.y;
      result.z = tmp0.z * tmp1.z + tmp2.z;
      result.w = tmp0.w * tmp1.w + tmp2.w;

    The multiplication and addition operations in this instruction are subject
    to the same rules as described for the MUL and ADD instructions.


    Section 2.14.5.16,  MAX:  Maximum

    The MAX instruction computes component-wise maximums of the values in the
    two operands to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x > tmp1.x) ? tmp0.x : tmp1.x;
      result.y = (tmp0.y > tmp1.y) ? tmp0.y : tmp1.y;
      result.z = (tmp0.z > tmp1.z) ? tmp0.z : tmp1.z;
      result.w = (tmp0.w > tmp1.w) ? tmp0.w : tmp1.w;


    Section 2.14.5.17,  MIN:  Minimum

    The MIN instruction computes component-wise minimums of the values in the
    two operands to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x > tmp1.x) ? tmp1.x : tmp0.x;
      result.y = (tmp0.y > tmp1.y) ? tmp1.y : tmp0.y;
      result.z = (tmp0.z > tmp1.z) ? tmp1.z : tmp0.z;
      result.w = (tmp0.w > tmp1.w) ? tmp1.w : tmp0.w;


    Section 2.14.5.18,  MOV:  Move

    The MOV instruction copies the value of the operand to yield a result
    vector.

      result = VectorLoad(op0);


    Section 2.14.5.19,  MUL:  Multiply

    The MUL instruction performs a component-wise multiply of the two operands
    to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.x * tmp1.x;
      result.y = tmp0.y * tmp1.y;
      result.z = tmp0.z * tmp1.z;
      result.w = tmp0.w * tmp1.w;

    The following rules apply to multiplication:

      1. <x> * <y> == <y> * <x>, for all <x> and <y>.
      2. +/-0.0 * <x> = +/-0.0, at least for all <x> that correspond to
         representable numbers (IEEE "not a number" and "infinity" encodings
         may be exceptions).
      3. +1.0 * <x> = <x>, for all <x>.

    Multiplication by zero and one should be invariant, as it may be used to
    evaluate conditional expressions without branching.


    Section 2.14.5.20,  POW:  Exponentiate

    The POW instruction approximates the value of the first scalar operand
    raised to the power of the second scalar operand and replicates it to all
    four components of the result vector.

      tmp0 = ScalarLoad(op0);
      tmp1 = ScalarLoad(op1);
      result.x = ApproxPower(tmp0, tmp1);
      result.y = ApproxPower(tmp0, tmp1);
      result.z = ApproxPower(tmp0, tmp1);
      result.w = ApproxPower(tmp0, tmp1);

    The exponentiation approximation function may be implemented using the
    base 2 exponentiation and logarithm approximation operations in the EX2
    and LG2 instructions.  In particular,

      ApproxPower(a,b) = ApproxExp2(b * ApproxLog2(a)).

    Note that a logarithm may be involved even for cases where the exponent is
    an integer.  This means that it may not be possible to exponentiate
    correctly with a negative base.  In constrast, it is possible in a
    "normal" mathematical formulation to raise negative numbers to integral
    powers (e.g., (-3)^2== 9, and (-0.5)^-2==4).


    Section 2.14.5.21,  RCP:  Reciprocal

    The RCP instruction approximates the reciprocal of the scalar operand and
    replicates it to all four components of the result vector.

      tmp = ScalarLoad(op0);
      result.x = ApproxReciprocal(tmp);
      result.y = ApproxReciprocal(tmp);
      result.z = ApproxReciprocal(tmp);
      result.w = ApproxReciprocal(tmp);

    The following rule applies to reciprocation:

      1. ApproxReciprocal(+1.0) = +1.0.


    Section 2.14.5.22,  RSQ:  Reciprocal Square Root

    The RSQ instruction approximates the reciprocal of the square root of the
    absolute value of the scalar operand and replicates it to all four
    components of the result vector.

      tmp = fabs(ScalarLoad(op0));
      result.x = ApproxRSQRT(tmp);
      result.y = ApproxRSQRT(tmp);
      result.z = ApproxRSQRT(tmp);
      result.w = ApproxRSQRT(tmp);


    Section 2.14.5.23,  SGE:  Set On Greater or Equal Than

    The SGE instruction performs a component-wise comparison of the two
    operands.  Each component of the result vector is 1.0 if the corresponding
    component of the first operands is greater than or equal that of the
    second, and 0.0 otherwise.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x >= tmp1.x) ? 1.0 : 0.0;
      result.y = (tmp0.y >= tmp1.y) ? 1.0 : 0.0;
      result.z = (tmp0.z >= tmp1.z) ? 1.0 : 0.0;
      result.w = (tmp0.w >= tmp1.w) ? 1.0 : 0.0;


    Section 2.14.5.24,  SLT:  Set On Less Than

    The SLT instruction performs a component-wise comparison of the two
    operands.  Each component of the result vector is 1.0 if the corresponding
    component of the first operand is less than that of the second, and 0.0
    otherwise.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x < tmp1.x) ? 1.0 : 0.0;
      result.y = (tmp0.y < tmp1.y) ? 1.0 : 0.0;
      result.z = (tmp0.z < tmp1.z) ? 1.0 : 0.0;
      result.w = (tmp0.w < tmp1.w) ? 1.0 : 0.0;


    Section 2.14.5.25,  SUB:  Subtract

    The SUB instruction performs a component-wise subtraction of the second
    operand from the first to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.x - tmp1.x;
      result.y = tmp0.y - tmp1.y;
      result.z = tmp0.z - tmp1.z;
      result.w = tmp0.w - tmp1.w;


    Section 2.14.5.26,  SWZ:  Extended Swizzle

    The SWZ instruction loads the single vector operand, and performs a
    swizzle operation more powerful than that provided for loading normal
    vector operands to yield an instruction vector.

    After the operand is loaded, the "x", "y", "z", and "w" components of the
    result vector are selected by the first, second, third, and fourth matches
    of the <extSwizComp> pattern in the <extendedSwizzle> rule.

    A result component can be selected from any of the four components of the
    operand or the constants 0.0 and 1.0.  The result component can also be
    optionally negated.  The following pseudocode describes the component
    selection method.  "operand" refers to the vector operand, "select" is an
    enumerant where the values ZERO, ONE, X, Y, Z, and W correspond to the
    <extSwizSel> rule matching "0", "1", "x", "y", "z", and "w", respectively.
    "negate" is TRUE if and only if the <optionalSign> rule in <extSwizComp>
    matches "-".

      float ExtSwizComponent(floatVec operand, enum select, boolean negate)
      {
          float result;
          switch (select) {
            case ZERO:  result = 0.0; break;
            case ONE:   result = 1.0; break;
            case X:     result = operand.x; break;
            case Y:     result = operand.y; break;
            case Z:     result = operand.z; break;
            case W:     result = operand.w; break;
          }
          if (negate) {
            result = -result;
          }
          return result;
      }

    The entire extended swizzle operation is then defined using the following
    pseudocode:

      tmp = VectorLoad(op0);
      result.x = ExtSwizComponent(tmp, xSelect, xNegate);
      result.y = ExtSwizComponent(tmp, ySelect, yNegate);
      result.z = ExtSwizComponent(tmp, zSelect, zNegate);
      result.w = ExtSwizComponent(tmp, wSelect, wNegate);

    "xSelect", "xNegate", "ySelect", "yNegate", "zSelect", "zNegate",
    "wSelect", and "wNegate" correspond to the "select" and "negate" values
    above for the four <extSwizComp> matches.  

    Since this instruction allows for component selection and negation for
    each individual component, the grammar does not allow the use of the
    normal swizzle and negation operations allowed for vector operands in
    other instructions.


    Section 2.14.5.27,  XPD:  Cross Product

    The XPD instruction computes the cross product using the first three
    components of its two vector operands to generate the x, y, and z
    components of the result vector.  The w component of the result vector is
    undefined.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.y * tmp1.z - tmp0.z * tmp1.y;
      result.y = tmp0.z * tmp1.x - tmp0.x * tmp1.z;
      result.z = tmp0.x * tmp1.y - tmp0.y * tmp1.x;


    Section 2.14.6,  Program Matrices

    In addition to GL's conventional matrices, several additional program
    matrices are available for use as program parameters.  These matrices have
    names of the form MATRIX<i>_ARB where <i> is between zero and <n>-1 where
    <n> is the value of the implementation-dependent constant
    MAX_PROGRAM_MATRICES_ARB.  The MATRIX<i>_ARB constants obey MATRIX<i>_ARB
    = MATRIX0_ARB + <i>.  The value of MAX_PROGRAM_MATRICES_ARB must be at
    least eight.  The maximum stack depth for program matrices is defined by
    the MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB and must be at least 1.


    Section 2.14.7  Required Vertex Program State 

    The state required to support program objects of all targets consists of:

      an integer for the program error position, initially -1;

      an array of ubytes for the program error string, initially empty;

      and the state that must be maintained to indicate which integers are
      currently in use as program object names.

    The state required to support the vertex program target consists of:

      a bit indicating whether or not program mode is enabled, initially
      disabled;

      a bit indicating whether or not vertex program two-sided color mode is
      enabled, initially disabled;

      a bit indicating whether or not vertex program point size mode is
      enabled, initially disabled;

      a set of MAX_PROGRAM_ENV_PARAMETERS_ARB four-component floating-point
      program environment parameters, initially set to (0,0,0,0);

      and an unsigned integer naming the currently bound vertex program,
      initially zero.

   The state required for each vertex program object consists of:

      an unsigned integer indicating the program object name;

      an array of type ubyte containing the program string, initially empty;

      an unsigned integer holding the length of the program string, initially
      zero;

      an enum indicating the program string format, initially
      PROGRAM_FORMAT_ASCII_ARB;

      five unsigned integers holding the number of instruction, temporary
      variable, vertex attribute binding, address register, and program
      parameter binding resources used by the program, initially all zero;

      five unsigned integers holding the number of native instruction,
      temporary variable, vertex attribute binding, address register, and
      program parameter binding resources used by the program, initially all
      zero;

      and a set of MAX_PROGRAM_LOCAL_PARAMETERS_ARB four-component
      floating-point program local parameters, initially set to (0,0,0,0).

   Initially, no vertex program objects exist.