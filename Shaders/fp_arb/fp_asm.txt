3.11  Fragment Programs

    The conventional GL texturing model described in section 3.8 is a
    configurable but essentially hard-wired sequence of per-fragment
    computations based on a canonical set of per-fragment parameters
    and texturing-related state such as texture images, texture 
    parameters, and texture environment parameters.  The general success 
    and utility of the conventional GL texturing model reflects its 
    basic correspondence to the typical texturing requirements of 3D 
    applications.

    However when the conventional GL texturing model is not sufficient, 
    the fragment program mode provides a substantially more flexible
    model for generating fragment colors.  The fragment program mode 
    permits applications to define their own fragment programs.

    A fragment program is a character string that specifies a sequence 
    of operations to perform.  Fragment program instructions are 
    typically 4-component vector operations that operate on per-fragment 
    attributes and program parameters.  Fragment programs execute on a 
    per-fragment basis and operate on each fragment completely 
    independently from any other fragments.  Fragment programs execute a 
    finite fixed sequence of instructions with no branching or looping.  
    Fragment programs execute without data hazards so results computed 
    in one instruction can be used immediately afterwards.  The result 
    of a fragment program is a set of fragment result registers that 
    becomes the color used by antialiasing application and/or a depth 
    value used in place of the interpolated depth value generated by 
    conventional rasterization.

    In fragment program mode, the color sum is subsumed by the fragment
    program.  An application desiring the primary and secondary colors
    to be summed must explicitly include this operation in its program.

    Fragment programs are defined to operate only in RGBA mode.  The 
    results of fragment program execution are undefined if the GL is in 
    color index mode.


    3.11.1  Program Objects

    The GL provides one or more program targets, each identifying a 
    portion of the GL that can be controlled through application-
    specified programs.  The program target for fragment programs is 
    FRAGMENT_PROGRAM_ARB.  Each program target has an associated program 
    object, called the current program object.  Each program target also 
    has a default program object, which is initially the current program 
    object.

    Each program object has an associated program string.  The command

      ProgramStringARB(enum target, enum format, sizei len, 
                       const void *string);

    updates the program string for the current program object for 
    <target>.  <format> describes the format of the program string, 
    which must currently be PROGRAM_FORMAT_ASCII_ARB.  <string> is a 
    pointer to the array of bytes representing the program string being 
    loaded, which need not be null-terminated.  The length of the array 
    is given by <len>.  If <string> is null-terminated, <len> should not 
    include the terminator.

    When a program string is loaded, it is interpreted according to 
    syntactic and semantic rules corresponding to the program target 
    specified by <target>.  If a program violates the syntactic or 
    semantic restrictions of the program target, ProgramStringARB 
    generates the error INVALID_OPERATION.  An implementation may also
    generate the error INVALID_OPERATION if the program would exceed
    the native resource limits defined in section 6.1.12.  A program
    which fails to load due to exceeding native resource limits must
    always fail, regardless of any other GL state.

    Additionally, ProgramString will update the program error position
    (PROGRAM_ERROR_POSITION_ARB) and error string 
    (PROGRAM_ERROR_STRING_ARB).  If a program fails to load, the value 
    of the program error position is set to the ubyte offset into the 
    specified program string indicating where the first program error 
    was detected.  If the program fails to load because of a semantic 
    restriction that is not detected until the program is fully 
    scanned, the error position is set to the value of <len>.  If a
    program loads successfully, the error position is set to the value
    negative one.  The implementation-dependent program error string 
    contains one or more error or warning messages.  If a program loads 
    succesfully, the error string may either contain warning messages or 
    be empty.

    Each program object has an associated array of program local 
    parameters.  The number and type of program local parameters is 
    target- and implementation-dependent.  For fragment programs, 
    program local parameters are four-component floating-point vectors.  
    The number of vectors is given by the implementation-dependent 
    constant MAX_PROGRAM_LOCAL_PARAMETERS_ARB, which must be at least 
    24.  The commands

      void ProgramLocalParameter4fARB(enum target, uint index,
                                      float x, float y, float z, float w);
      void ProgramLocalParameter4fvARB(enum target, uint index, 
                                       const float *params);
      void ProgramLocalParameter4dARB(enum target, uint index,
                                      double x, double y, double z, double w);
      void ProgramLocalParameter4dvARB(enum target, uint index, 
                                       const double *params);

    update the values of the program local parameter numbered <index>
    belonging to the program object currently bound to <target>.  For
    ProgramLocalParameter4fARB and ProgramLocalParameter4dARB, the four
    components of the parameter are updated with the values of <x>, <y>, 
    <z>, and <w>, respectively.  For ProgramLocalParameter4fvARB and
    ProgramLocalParameter4dvARB, the four components of the parameter 
    are updated with the array of four values pointed to by <params>.  
    The error INVALID_VALUE is generated if <index> is greater than or 
    equal to the number of program local parameters supported by 
    <target>.

    Additionally, each program target has an associated array of program 
    environment parameters.  Unlike program local parameters, program
    environment parameters are shared by all program objects of a given 
    target.  The number and type of program environment parameters is 
    target- and implementation-dependent.  For fragment programs, 
    program environment parameters are four-component floating-point 
    vectors.  The number of vectors is given by the implementation-
    dependent constant MAX_PROGRAM_ENV_PARAMETERS_ARB, which must be at 
    least 24.  The commands

      void ProgramEnvParameter4fARB(enum target, uint index,
                                    float x, float y, float z, float w);
      void ProgramEnvParameter4fvARB(enum target, uint index,
                                     const float *params);
      void ProgramEnvParameter4dARB(enum target, uint index,
                                    double x, double y, double z, double w);
      void ProgramEnvParameter4dvARB(enum target, uint index,
                                     const double *params);

    update the values of the program environment parameter numbered 
    <index> for the given program target <target>.  For 
    ProgramEnvParameter4fARB and ProgramEnvParameter4dARB, the four 
    components of the parameter are updated with the values of <x>, <y>, 
    <z>, and <w>, respectively.  For ProgramEnvParameter4fvARB and 
    ProgramEnvParameter4dvARB, the four components of the parameter are 
    updated with the array of four values pointed to by <params>.  The 
    error INVALID_VALUE is generated if <index> is greater than or equal 
    to the number of program environment parameters supported by 
    <target>.

    Each program target has a default program object.  Additionally, 
    named program objects can be created and operated upon.  The name 
    space for program objects is the positive integers and is shared by 
    programs of all targets.  The name zero is reserved by the GL.

    A named program object is created by binding an unused program 
    object name to a valid program target.  The binding is effected by 
    calling 

      BindProgramARB(enum target, uint program);

    with <target> set to the desired program target and <program> set to 
    the unused program name.  The resulting program object has a program 
    target given by <target> and is assigned target-specific default 
    values (see section 3.11.8 for fragment programs).  BindProgramARB 
    may also be used to bind an existing program object to a program 
    target.  If <program> is zero, the default program object for 
    <target> is bound.  If <program> is the name of an existing program
    object whose associated program target is <target>, the named 
    program object is bound.  The error INVALID_OPERATION is generated 
    if <program> names an existing program object whose associated 
    program target is anything other than <target>.

    Programs objects are deleted by calling

      void DeleteProgramsARB(sizei n, const uint *programs);

    <programs> contains <n> names of programs to be deleted.  After a 
    program object is deleted, its name is again unused.  If a program 
    object that is bound to any target is deleted, it is as though 
    BindProgramARB is first executed with same target and a <program> of 
    zero.  Unused names in <programs> are silently ignored, as is the 
    value zero.

    The command

      void GenProgramsARB(sizei n, uint *programs);

    returns <n> currently unused program names in <programs>.  These 
    names are marked as used, for the purposes of GenProgramsARB only, 
    but objects are created only when they are first bound using 
    BindProgramARB.


    3.11.2  Fragment Program Grammar and Semantic Restrictions

    Fragment program strings are specified as an array of ASCII 
    characters containing the program text.  When a fragment program is 
    loaded by a call to ProgramStringARB, the program string is parsed 
    into a set of tokens possibly separated by whitespace.  Spaces, 
    tabs, newlines, carriage returns, and comments are considered 
    whitespace.  Comments begin with the character "#" and are 
    terminated by a newline, a carriage return, or the end of the 
    program array.

    The Backus-Naur Form (BNF) grammar below specifies the syntactically 
    valid sequences for fragment programs.  The set of valid tokens can 
    be inferred from the grammar.  The token "" represents an empty 
    string and is used to indicate optional rules.  A program is invalid 
    if it contains any undefined tokens or characters.

    A fragment program is required to begin with the header string 
    "!!ARBfp1.0", without any preceding whitespace.  This string 
    identifies the subsequent program text as a fragment program 
    (version 1.0) that should be parsed according to the following 
    grammar and semantic rules.  Program string parsing begins with the 
    character immediately following the header string.

    <program>              ::= <optionSequence> <statementSequence> "END"

    <optionSequence>       ::= <optionSequence> <option>
                             | ""

    <option>               ::= "OPTION" <identifier> ";"

    <statementSequence>    ::= <statementSequence> <statement>
                             | ""

    <statement>            ::= <instruction> ";"
                             | <namingStatement> ";"

    <instruction>          ::= <ALUInstruction>
                             | <TexInstruction>

    <ALUInstruction>       ::= <VECTORop_instruction>
                             | <SCALARop_instruction>
                             | <BINSCop_instruction>
                             | <BINop_instruction>
                             | <TRIop_instruction>
                             | <SWZ_instruction>

    <TexInstruction>       ::= <SAMPLE_instruction>
                             | <KIL_instruction>

    <VECTORop_instruction> ::= <VECTORop> <maskedDstReg> "," 
                               <vectorSrcReg>

    <VECTORop>             ::= "ABS" | "ABS_SAT"
                             | "FLR" | "FLR_SAT"
                             | "FRC" | "FRC_SAT"
                             | "LIT" | "LIT_SAT"
                             | "MOV" | "MOV_SAT"

    <SCALARop_instruction> ::= <SCALARop> <maskedDstReg> ","  
                               <scalarSrcReg> 
 
    <SCALARop>             ::= "COS" | "COS_SAT"
                             | "EX2" | "EX2_SAT"
                             | "LG2" | "LG2_SAT"
                             | "RCP" | "RCP_SAT"
                             | "RSQ" | "RSQ_SAT"
                             | "SIN" | "SIN_SAT"
                             | "SCS" | "SCS_SAT"
 
    <BINSCop_instruction>  ::= <BINSCop> <maskedDstReg> "," 
                               <scalarSrcReg> "," <scalarSrcReg> 

    <BINSCop>              ::= "POW" | "POW_SAT"
 
    <BINop_instruction>    ::= <BINop> <maskedDstReg> ","
                               <vectorSrcReg> "," <vectorSrcReg>

    <BINop>                ::= "ADD" | "ADD_SAT"
                             | "DP3" | "DP3_SAT"
                             | "DP4" | "DP4_SAT"
                             | "DPH" | "DPH_SAT"
                             | "DST" | "DST_SAT"
                             | "MAX" | "MAX_SAT"
                             | "MIN" | "MIN_SAT"
                             | "MUL" | "MUL_SAT"
                             | "SGE" | "SGE_SAT"
                             | "SLT" | "SLT_SAT"
                             | "SUB" | "SUB_SAT"
                             | "XPD" | "XPD_SAT"

    <TRIop_instruction>    ::= <TRIop> <maskedDstReg> ","
                               <vectorSrcReg> "," <vectorSrcReg> ","
                               <vectorSrcReg>

    <TRIop>                ::= "CMP" | "CMP_SAT"
                             | "LRP" | "LRP_SAT"
                             | "MAD" | "MAD_SAT"

    <SWZ_instruction>      ::= <SWZop> <maskedDstReg> "," 
                               <srcReg> "," <extendedSwizzle>

    <SWZop>                ::= "SWZ" | "SWZ_SAT"

    <SAMPLE_instruction>   ::= <SAMPLEop> <maskedDstReg> ","
                               <vectorSrcReg> "," <texImageUnit> "," 
                               <texTarget>

    <SAMPLEop>             ::= "TEX" | "TEX_SAT"
                             | "TXP" | "TXP_SAT"
                             | "TXB" | "TXB_SAT"

    <KIL_instruction>      ::= "KIL" <vectorSrcReg>

    <texImageUnit>         ::= "texture" <optTexImageUnitNum>

    <texTarget>            ::= "1D"
                             | "2D"
                             | "3D"
                             | "CUBE"
                             | "RECT"

    <optTexImageUnitNum>   ::= ""
                             | "[" <texImageUnitNum> "]"

    <texImageUnitNum>      ::= <integer> from 0 to 
                               MAX_TEXTURE_IMAGE_UNITS_ARB-1

    <scalarSrcReg>         ::= <optionalSign> <srcReg> <scalarSuffix>

    <vectorSrcReg>         ::= <optionalSign> <srcReg> <optionalSuffix> 
 
    <maskedDstReg>         ::= <dstReg> <optionalMask>

    <extendedSwizzle>      ::= <xyzwExtendedSwizzle>
                             | <rgbaExtendedSwizzle>

    <xyzwExtendedSwizzle>  ::= <xyzwExtSwizComp> "," <xyzwExtSwizComp> "," 
                               <xyzwExtSwizComp> "," <xyzwExtSwizComp>

    <rgbaExtendedSwizzle>  ::= <rgbaExtSwizComp> "," <rgbaExtSwizComp> "," 
                               <rgbaExtSwizComp> "," <rgbaExtSwizComp>

    <xyzwExtSwizComp>      ::= <optionalSign> <xyzwExtSwizSel>

    <rgbaExtSwizComp>      ::= <optionalSign> <rgbaExtSwizSel>

    <xyzwExtSwizSel>       ::= "0" 
                             | "1" 
                             | <xyzwComponent>

    <rgbaExtSwizSel>       ::= "0" 
                             | "1" 
                             | <rgbaComponent>

    <srcReg>               ::= <fragmentAttribReg>
                             | <temporaryReg>
                             | <progParamReg>

    <dstReg>               ::= <temporaryReg>
                             | <fragmentResultReg>

    <fragmentAttribReg>    ::= <establishedName>
                             | <fragAttribBinding>

    <temporaryReg>         ::= <establishedName>

    <progParamReg>         ::= <progParamSingle>
                             | <progParamArray> "[" <progParamArrayAbs> "]"
                             | <paramSingleItemUse>

    <progParamSingle>      ::= <establishedName>

    <progParamArray>       ::= <establishedName>

    <progParamArrayAbs>    ::= <integer>

    <fragmentResultReg>    ::= <establishedName>
                             | <resultBinding>

    <scalarSuffix>         ::= "." <component>

    <optionalSuffix>       ::= "" 
                             | "." <component> 
                             | "." <xyzwComponent> <xyzwComponent>
                                   <xyzwComponent> <xyzwComponent>
                             | "." <rgbaComponent> <rgbaComponent>
                                   <rgbaComponent> <rgbaComponent>
 
    <component>            ::= <xyzwComponent>
                             | <rgbaComponent>

    <xyzwComponent>        ::= "x" | "y" | "z" | "w"

    <rgbaComponent>        ::= "r" | "g" | "b" | "a"

    <optionalMask>         ::= ""
                             | <xyzwMask>
                             | <rgbaMask>

    <xyzwMask>             ::= "." "x"
                             | "." "y"
                             | "." "xy"
                             | "." "z"
                             | "." "xz"
                             | "." "yz"
                             | "." "xyz"
                             | "." "w"
                             | "." "xw"
                             | "." "yw"
                             | "." "xyw"
                             | "." "zw"
                             | "." "xzw"
                             | "." "yzw"
                             | "." "xyzw"

    <rgbaMask>             ::= "." "r"
                             | "." "g"
                             | "." "rg"
                             | "." "b"
                             | "." "rb"
                             | "." "gb"
                             | "." "rgb"
                             | "." "a"
                             | "." "ra"
                             | "." "ga"
                             | "." "rga"
                             | "." "ba"
                             | "." "rba"
                             | "." "gba"
                             | "." "rgba"

    <namingStatement>      ::= <ATTRIB_statement>
                             | <PARAM_statement>
                             | <TEMP_statement>
                             | <OUTPUT_statement>
                             | <ALIAS_statement>

    <ATTRIB_statement>     ::= "ATTRIB" <establishName> "="
                                 <fragAttribBinding>

    <fragAttribBinding>    ::= "fragment" "." <fragAttribItem>

    <fragAttribItem>       ::= "color" <optColorType>
                             | "texcoord" <optTexCoordNum>
                             | "fogcoord"
                             | "position"

    <PARAM_statement>      ::= <PARAM_singleStmt>
                             | <PARAM_multipleStmt>

    <PARAM_singleStmt>     ::= "PARAM" <establishName> <paramSingleInit>

    <PARAM_multipleStmt>   ::= "PARAM" <establishName> "[" <optArraySize> "]"
                                   <paramMultipleInit>

    <optArraySize>         ::= ""
                             | <integer> from 1 to MAX_PROGRAM_PARAMETERS_ARB
                                 (maximum number of allowed program 
                                  parameter bindings)

    <paramSingleInit>      ::= "=" <paramSingleItemDecl>

    <paramMultipleInit>    ::= "=" "{" <paramMultInitList> "}"

    <paramMultInitList>    ::= <paramMultipleItem>
                             | <paramMultipleItem> "," <paramMultInitList>

    <paramSingleItemDecl>  ::= <stateSingleItem>
                             | <programSingleItem>
                             | <paramConstDecl>

    <paramSingleItemUse>   ::= <stateSingleItem>
                             | <programSingleItem>
                             | <paramConstUse>

    <paramMultipleItem>    ::= <stateMultipleItem>
                             | <programMultipleItem>
                             | <paramConstDecl>

    <stateMultipleItem>    ::= <stateSingleItem>
                             | "state" "." <stateMatrixRows>

    <stateSingleItem>      ::= "state" "." <stateMaterialItem>
                             | "state" "." <stateLightItem>
                             | "state" "." <stateLightModelItem>
                             | "state" "." <stateLightProdItem>
                             | "state" "." <stateTexEnvItem>
                             | "state" "." <stateFogItem>
                             | "state" "." <stateDepthItem>
                             | "state" "." <stateMatrixRow>

    <stateMaterialItem>    ::= "material" <optFaceType> "." <stateMatProperty>

    <stateMatProperty>     ::= "ambient"
                             | "diffuse"
                             | "specular"
                             | "emission"
                             | "shininess"

    <stateLightItem>       ::= "light" "[" <stateLightNumber> "]" "." 
                                 <stateLightProperty>

    <stateLightProperty>   ::= "ambient"
                             | "diffuse" 
                             | "specular"
                             | "position"
                             | "attenuation"
                             | "spot" "." <stateSpotProperty>
                             | "half"

    <stateSpotProperty>    ::= "direction" 

    <stateLightModelItem>  ::= "lightmodel" <stateLModProperty>

    <stateLModProperty>    ::= "." "ambient"
                             | <optFaceType> "." "scenecolor"

    <stateLightProdItem>   ::= "lightprod" "[" <stateLightNumber> "]"
                                 <optFaceType> "." <stateLProdProperty>

    <stateLProdProperty>   ::= "ambient"
                             | "diffuse"
                             | "specular"

    <stateLightNumber>     ::= <integer> from 0 to MAX_LIGHTS-1

    <stateTexEnvItem>      ::= "texenv" <optLegacyTexUnitNum> "." 
                                 <stateTexEnvProperty>

    <stateTexEnvProperty>  ::= "color"

    <optLegacyTexUnitNum>  ::= ""
                             | "[" <legacyTexUnitNum> "]"

    <legacyTexUnitNum>     ::= <integer> from 0 to MAX_TEXTURE_UNITS-1

    <stateFogItem>         ::= "fog" "." <stateFogProperty>

    <stateFogProperty>     ::= "color" 
                             | "params" 

    <stateDepthItem>       ::= "depth" "." <stateDepthProperty>

    <stateDepthProperty>   ::= "range" 

    <stateMatrixRow>       ::= <stateMatrixItem> "." "row" "[" 
                                  <stateMatrixRowNum> "]"

    <stateMatrixRows>      ::= <stateMatrixItem> <optMatrixRows>

    <optMatrixRows>        ::= ""
                             | "." "row" "[" <stateMatrixRowNum> ".." 
                                  <stateMatrixRowNum> "]"

    <stateMatrixItem>      ::= "matrix" "." <stateMatrixName> 
                               <stateOptMatModifier>

    <stateOptMatModifier>  ::= ""
                             | "." <stateMatModifier>

    <stateMatModifier>     ::= "inverse" 
                             | "transpose" 
                             | "invtrans"

    <stateMatrixRowNum>    ::= <integer> from 0 to 3

    <stateMatrixName>      ::= "modelview" <stateOptModMatNum>
                             | "projection"
                             | "mvp"
                             | "texture" <optTexCoordNum>
                             | "palette" "[" <statePaletteMatNum> "]"
                             | "program" "[" <stateProgramMatNum> "]"
                             
    <stateOptModMatNum>    ::= ""
                             | "[" <stateModMatNum> "]"

    <stateModMatNum>       ::= <integer> from 0 to MAX_VERTEX_UNITS_ARB-1

    <optTexCoordNum>       ::= ""
                             | "[" <texCoordNum> "]"

    <texCoordNum>          ::= <integer> from 0 to MAX_TEXTURE_COORDS_ARB-1

    <statePaletteMatNum>   ::= <integer> from 0 to MAX_PALETTE_MATRICES_ARB-1

    <stateProgramMatNum>   ::= <integer> from 0 to MAX_PROGRAM_MATRICES_ARB-1

    <programSingleItem>    ::= <progEnvParam>
                             | <progLocalParam>

    <programMultipleItem>  ::= <progEnvParams>
                             | <progLocalParams>

    <progEnvParams>        ::= "program" "." "env" 
                                 "[" <progEnvParamNums> "]"

    <progEnvParamNums>     ::= <progEnvParamNum>
                             | <progEnvParamNum> ".." <progEnvParamNum>

    <progEnvParam>         ::= "program" "." "env" 
                                 "[" <progEnvParamNum> "]"

    <progLocalParams>      ::= "program" "." "local" 
                                 "[" <progLocalParamNums> "]"

    <progLocalParamNums>   ::= <progLocalParamNum>
                             | <progLocalParamNum> ".." <progLocalParamNum>

    <progLocalParam>       ::= "program" "." "local" 
                                 "[" <progLocalParamNum> "]"

    <progEnvParamNum>      ::= <integer> from 0 to
                               MAX_PROGRAM_ENV_PARAMETERS_ARB - 1 

    <progLocalParamNum>    ::= <integer> from 0 to
                               MAX_PROGRAM_LOCAL_PARAMETERS_ARB - 1 

    <paramConstDecl>       ::= <paramConstScalarDecl>
                             | <paramConstVector>

    <paramConstUse>        ::= <paramConstScalarUse>
                             | <paramConstVector>

    <paramConstScalarDecl> ::= <signedFloatConstant>

    <paramConstScalarUse>  ::= <floatConstant>

    <paramConstVector>     ::= "{" <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> ","
                                   <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> ","
                                   <signedFloatConstant> "," 
                                   <signedFloatConstant> "}"

    <signedFloatConstant>  ::= <optionalSign> <floatConstant>

    <floatConstant>        ::= see text

    <optionalSign>         ::= ""
                             | "-"
                             | "+"

    <TEMP_statement>       ::= "TEMP" <varNameList>

    <varNameList>          ::= <establishName>
                             | <establishName> "," <varNameList>

    <OUTPUT_statement>     ::= "OUTPUT" <establishName> "="
                                 <resultBinding>

    <resultBinding>        ::= "result" "." "color"
                             | "result" "." "depth"

    <optFaceType>          ::= ""
                             | "." "front"
                             | "." "back"

    <optColorType>         ::= ""
                             | "." "primary"
                             | "." "secondary"

    <ALIAS_statement>      ::= "ALIAS" <establishName> "="
                                 <establishedName>

    <establishName>        ::= <identifier>

    <establishedName>      ::= <identifier>

    <identifier>           ::= see text

    The <integer> rule matches an integer constant.  The integer 
    consists of a sequence of one or more digits ("0" through "9").

    The <floatConstant> rule matches a floating-point constant 
    consisting of an integer part, a decimal point, a fraction part, an 
    "e" or "E", and an optionally signed integer exponent.  The integer 
    and fraction parts both consist of a sequence of one or more digits 
    ("0" through "9").  Either the integer part or the fraction parts 
    (not both) may be missing; either the decimal point or the "e" (or 
    "E") and the exponent (not both) may be missing.

    The <identifier> rule matches a sequence of one or more letters ("A"
    through "Z", "a" through "z"), digits ("0" through "9), underscores 
    ("_"), or dollar signs ("$"); the first character must not be a 
    number.  Upper and lower case letters are considered different 
    (names are case-sensitive).  The following strings are reserved 
    keywords and may not be used as identifiers:

        ABS, ABS_SAT, ADD, ADD_SAT, ALIAS, ATTRIB, CMP, CMP_SAT, COS,
        COS_SAT, DP3, DP3_SAT, DP4, DP4_SAT, DPH, DPH_SAT, DST, DST_SAT, 
        END, EX2, EX2_SAT, FLR, FLR_SAT, FRC, FRC_SAT, KIL, LG2, 
        LG2_SAT, LIT, LIT_SAT, LRP, LRP_SAT, MAD, MAD_SAT, MAX, MAX_SAT, 
        MIN, MIN_SAT, MOV, MOV_SAT, MUL, MUL_SAT, OPTION, OUTPUT, PARAM, 
        POW, POW_SAT, RCP, RCP_SAT, RSQ, RSQ_SAT, SIN, SIN_SAT, SCS, 
        SCS_SAT, SGE, SGE_SAT, SLT, SLT_SAT, SUB, SUB_SAT, SWZ, SWZ_SAT, 
        TEMP, TEX, TEX_SAT, TXB, TXB_SAT, TXP, TXP_SAT, XPD, XPD_SAT, 
        fragment, program, result, state, and texture.

    The error INVALID_OPERATION is generated if a fragment program fails 
    to load because it is not syntactically correct or for one of the 
    semantic restrictions described in the following sections.

    A successfully loaded fragment program is parsed into a sequence of
    instructions.  Each instruction is identified by its tokenized name.  
    The operation of these instructions when executed is defined in 
    section 3.11.5.

    A successfully loaded program string replaces the program string
    previously loaded into the specified program object.  If the 
    OUT_OF_MEMORY error is generated by ProgramStringARB, no change is 
    made to the previous contents of the current program object.


    3.11.3  Fragment Program Variables

    Fragment programs may access a number of different variables during 
    their execution.  The following sections define the variables that 
    can be declared and used by a fragment program.

    Explicit variable declarations allow a fragment program to establish 
    a variable name that can be used to refer to a specified resource in 
    subsequent instructions.  A fragment program will fail to load if it 
    declares the same variable name more than once or if it refers to a
    variable name that has not been previously declared in the program 
    string.

    Implicit variable declarations allow a fragment program to use the 
    name of certain available resources by name.


    3.11.3.1  Fragment Attributes

    Fragment program attribute variables are a set of four-component
    floating-point vectors holding the attributes of the fragment being
    processed.  Fragment attribute variables are read-only during 
    fragment program execution.

    Fragment attribute variables can be declared explicitly using the
    <ATTRIB_statement> grammar rule, or implicitly using the
    <fragAttribBinding> grammar rule in an executable instruction.

    Each fragment attribute variable is bound to a single item of 
    fragment state according to the <fragAttrBinding> grammar rule.  The 
    set of GL state that can be bound to a fragment attribute variable 
    is given in Table X.1.  Fragment attribute variables are initialized 
    at each fragment program invocation with the current values of the 
    bound state.

      Fragment Attribute Binding  Components  Underlying State
      --------------------------  ----------  ----------------------------
      fragment.color              (r,g,b,a)   primary color
      fragment.color.primary      (r,g,b,a)   primary color
      fragment.color.secondary    (r,g,b,a)   secondary color
      fragment.texcoord           (s,t,r,q)   texture coordinate, unit 0
      fragment.texcoord[n]        (s,t,r,q)   texture coordinate, unit n
      fragment.fogcoord           (f,0,0,1)   fog distance/coordinate
      fragment.position           (x,y,z,1/w) window position

      Table X.1:  Fragment Attribute Bindings.  The "Components" column
      indicates the mapping of the state in the "Underlying State" 
      column.  Bindings containing "[n]" require an integer value of <n> 
      to select an individual item.

    If a fragment attribute binding matches "fragment.color" or
    "fragment.color.primary", the "x", "y", "z", and "w" components of 
    the fragment attribute variable are filled with the "r", "g", "b", 
    and "a" components, respectively, of the fragment color.  Each 
    fixed-point color component undergoes an implied conversion to
    floating point.  This conversion must leave the values 0 and 1
    invariant.

    If a fragment attribute binding matches "fragment.color.secondary", 
    the "x", "y", "z", and "w" components of the fragment attribute 
    variable are filled with the "r", "g", "b", and "a" components, 
    respectively, of the fragment secondary color.  Each fixed-point 
    color component undergoes an implied conversion to floating point.  
    This conversion must leave the values 0 and 1 invariant.

    If a fragment attribute binding matches "fragment.texcoord" or
    "fragment.texcoord[n]", the "x", "y", "z", and "w" components of the 
    fragment attribute variable are filled with the "s", "t", "r", and 
    "q" components, respectively, of the fragment texture coordinates 
    for texture unit <n>.  If "[n]" is omitted, texture unit zero is 
    used.

    If a fragment attribute binding matches "fragment.fogcoord", the "x" 
    component of the fragment attribute variable is filled with either
    the fragment eye distance or the fog coordinate, depending on 
    whether the fog source is set to FRAGMENT_DEPTH_EXT or 
    FOG_COORDINATE_EXT, respectively.  The "y", "z", and "w" coordinates 
    are filled with 0, 0, and 1, respectively.

    If a fragment attribute binding matches "fragment.position", the "x"
    and "y" components of the fragment attribute variable are filled 
    with the (x,y) window coordinates of the fragment center, relative 
    to the lower left corner of the window.  The "z" component is filled 
    with the fragment's z window coordinate.  This z window coordinate 
    undergoes an implied conversion to floating point.  This conversion 
    must leave the values 0 and 1 invariant.  The "w" component is 
    filled with the reciprocal of the fragment's clip w coordinate.

    On some implementations, the components of fragment.position may be
    generated by interpolating per-vertex position values.  This may
    produce x and y window coordinates that don't exactly match those of
    the fragment center and z window coordinates that do not exactly
    match those generated by fixed-function rasterization.  Therefore,
    there is no guaranteed invariance between the final z window
    coordinates of fragments processed by fragment programs that write
    depth values and fragments processed by any other means, even if the
    fragment programs in question simply copy the z value from the
    fragment.position binding.


    3.11.3.2  Fragment Program Parameters

    Fragment program parameter variables are a set of four-component
    floating-point vectors used as constants during fragment program 
    execution.  Fragment program parameters retain their values across 
    fragment program invocations, although their values can change 
    between invocations due to GL state changes.

    Single program parameter variables and arrays of program parameter
    variables can be declared explicitly using the <PARAM_statement> 
    grammar rule.  Single program parameter variables can also be 
    declared implicitly using the <paramSingleItemUse> grammar rule in 
    an executable instruction.

    Each single program parameter variable is bound to a constant vector 
    or to a GL state vector according to the <paramSingleInit> grammar 
    rule.  Individual items of a program parameter array are bound to 
    constant vectors or GL state vectors according to the 
    <programMultipleInit> grammar rule.  The set of GL state that can be 
    bound to program parameter variables are given in Tables X.2.1 
    through X.2.4.


    Constant Bindings

    A program parameter variable can be bound to a scalar or vector 
    constant using the <paramConstDecl> grammar rule (explicit 
    declarations) or the <paramConstUse> grammar rule (implicit 
    declarations).

    If a program parameter binding matches the <paramConstScalarDecl> or
    <paramConstScalarUse> grammar rules, the corresponding program 
    parameter variable is bound to the vector (X,X,X,X), where X is the 
    value of the specified constant.  Note that the 
    <paramConstScalarUse> grammar rule, used only in implicit 
    declarations, allows only non-negative constants.  This 
    disambiguates cases like "-2", which could conceivably be taken to 
    mean either the vector "(2,2,2,2)" with all components negated or 
    "(-2,-2,-2,-2)" without negation.  Only the former interpretation is 
    allowed by the grammar.

    If a program parameter binding matches <paramConstVector>, the
    corresponding program parameter variable is bound to the vector
    (X,Y,Z,W), where X, Y, Z, and W are the values corresponding to the 
    first, second, third, and fourth match of <signedFloatConstant>.  If 
    fewer than four constants are specified, Y, Z, and W assume the 
    values 0.0, 0.0, and 1.0, if their respective constants are not 
    specified.

    Program parameter variables initialized to constant values can never 
    be modified.


    Program Environment/Local Parameter Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      program.env[a]                 (x,y,z,w)   program environment 
                                                 parameter a
      program.local[a]               (x,y,z,w)   program local parameter a
      program.env[a..b]              (x,y,z,w)   program environment
                                                 parameters a through b
      program.local[a..b]            (x,y,z,w)   program local parameters
                                                 a through b

      Table X.2.1:  Program Environment/Local Parameter Bindings.  <a> 
      and <b> indicate parameter numbers, where <a> must be less than or 
      equal to <b>.

    If a program parameter binding matches "program.env[a]" or
    "program.local[a]", the four components of the program parameter 
    variable are filled with the four components of program environment 
    parameter <a> or program local parameter <a>, respectively.

    Additionally, for program parameter array bindings, 
    "program.env[a..b]" and "program.local[a..b]" are equivalent to 
    specifying program environment parameters <a> through <b> in order 
    or program local parameters <a> through <b> in order, respectively.  
    In either case, a program will fail to load if <a> is greater than 
    <b>.


    Material Property Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      state.material.ambient         (r,g,b,a)   front ambient material color
      state.material.diffuse         (r,g,b,a)   front diffuse material color
      state.material.specular        (r,g,b,a)   front specular material color
      state.material.emission        (r,g,b,a)   front emissive material color
      state.material.shininess       (s,0,0,1)   front material shininess
      state.material.front.ambient   (r,g,b,a)   front ambient material color
      state.material.front.diffuse   (r,g,b,a)   front diffuse material color
      state.material.front.specular  (r,g,b,a)   front specular material color
      state.material.front.emission  (r,g,b,a)   front emissive material color
      state.material.front.shininess (s,0,0,1)   front material shininess
      state.material.back.ambient    (r,g,b,a)   back ambient material color
      state.material.back.diffuse    (r,g,b,a)   back diffuse material color
      state.material.back.specular   (r,g,b,a)   back specular material color
      state.material.back.emission   (r,g,b,a)   back emissive material color
      state.material.back.shininess  (s,0,0,1)   back material shininess

      Table X.2.2:  Material Property Bindings.  If a material face is 
      not specified in the binding, the front property is used.

    If a program parameter binding matches any of the material 
    properties listed in Table X.2.2, the program parameter variable is 
    filled according to the table.  For ambient, diffuse, specular, or 
    emissive colors, the "x", "y", "z", and "w" components are filled 
    with the "r", "g", "b", and "a" components, respectively, of the 
    corresponding material color.  For material shininess, the "x" 
    component is filled with the material's specular exponent, and the 
    "y", "z", and "w" components are filled with 0, 0, and 1, 
    respectively.  Bindings containing ".back" refer to the back 
    material; all other bindings refer to the front material.

    Material properties can be changed inside a Begin/End pair, either
    directly by calling Material, or indirectly through color material.
    However, such property changes are not guaranteed to update program
    parameter bindings until the following End command.  Program 
    parameter variables bound to material properties changed inside a 
    Begin/End pair are undefined until the following End command.


    Light Property Bindings

      Binding                        Components  Underlying State
      -----------------------------  ----------  ----------------------------
      state.light[n].ambient         (r,g,b,a)   light n ambient color
      state.light[n].diffuse         (r,g,b,a)   light n diffuse color
      state.light[n].specular        (r,g,b,a)   light n specular color
      state.light[n].position        (x,y,z,w)   light n position
      state.light[n].attenuation     (a,b,c,e)   light n attenuation constants
                                                 and spot light exponent
      state.light[n].spot.direction  (x,y,z,c)   light n spot direction and
                                                 cutoff angle cosine
      state.light[n].half            (x,y,z,1)   light n infinite half-angle
      state.lightmodel.ambient       (r,g,b,a)   light model ambient color
      state.lightmodel.scenecolor    (r,g,b,a)   light model front scene color
      state.lightmodel      .        (r,g,b,a)   light model front scene color
               front.scenecolor
      state.lightmodel      .        (r,g,b,a)   light model back scene color
               back.scenecolor
      state.lightprod[n].ambient     (r,g,b,a)   light n / front material
                                                 ambient color product
      state.lightprod[n].diffuse     (r,g,b,a)   light n / front material
                                                 diffuse color product
      state.lightprod[n].specular    (r,g,b,a)   light n / front material
                                                 specular color product
      state.lightprod[n].            (r,g,b,a)   light n / front material
              front.ambient                      ambient color product
      state.lightprod[n].            (r,g,b,a)   light n / front material
              front.diffuse                      diffuse color product
      state.lightprod[n].            (r,g,b,a)   light n / front material
              front.specular                     specular color product
      state.lightprod[n].            (r,g,b,a)   light n / back material
              back.ambient                       ambient color product
      state.lightprod[n].            (r,g,b,a)   light n / back material
              back.diffuse                       diffuse color product
      state.lightprod[n].            (r,g,b,a)   light n / back material
              back.specular                      specular color product

      Table X.2.3: Light Property Bindings.  <n> indicates a light 
      number.

    If a program parameter binding matches "state.light[n].ambient",
    "state.light[n].diffuse", or "state.light[n].specular", the "x", 
    "y", "z", and "w" components of the program parameter variable are 
    filled with the "r", "g", "b", and "a" components, respectively, of 
    the corresponding light color.

    If a program parameter binding matches "state.light[n].position", 
    the "x", "y", "z", and "w" components of the program parameter 
    variable are filled with the "x", "y", "z", and "w" components, 
    respectively, of the light position.
    
    If a program parameter binding matches "state.light[n].attenuation", 
    the "x", "y", and "z" components of the program parameter variable 
    are filled with the constant, linear, and quadratic attenuation 
    parameters of the specified light, respectively (section 2.13.1).  
    The "w" component of the program parameter variable is filled with 
    the spot light exponent of the specified light.

    If a program parameter binding matches 
    "state.light[n].spot.direction", the "x", "y", and "z" components of 
    the program parameter variable are filled with the "x", "y", and "z" 
    components of the spot light direction of the specified light, 
    respectively (section 2.13.1).  The "w" component of the program 
    parameter variable is filled with the cosine of the spot light 
    cutoff angle of the specified light.

    If a program parameter binding matches "state.light[n].half", the 
    "x", "y", and "z" components of the program parameter variable are 
    filled with the x, y, and z components, respectively, of the 
    normalized infinite half-angle vector

      h_inf = || P + (0, 0, 1) ||.

    The "w" component is filled with 1.  In the computation of h_inf, P
    consists of the x, y, and z coordinates of the normalized vector 
    from the eye position P_e to the eye-space light position P_pli 
    (section 2.13.1).  h_inf is defined to correspond to the normalized 
    half-angle vector when using an infinite light (w coordinate of the 
    position is zero) and an infinite viewer (v_bs is FALSE).  For local 
    lights or a local viewer, h_inf is well-defined but does not match 
    the normalized half-angle vector, which will vary depending on the 
    vertex position.

    If a program parameter binding matches "state.lightmodel.ambient", 
    the "x", "y", "z", and "w" components of the program parameter 
    variable are filled with the "r", "g", "b", and "a" components of 
    the light model ambient color, respectively.

    If a program parameter binding matches "state.lightmodel.scenecolor" 
    or "state.lightmodel.front.scenecolor", the "x", "y", and "z" 
    components of the program parameter variable are filled with the 
    "r", "g", and "b" components respectively of the "front scene color"

      c_scene = a_cs * a_cm + e_cm,

    where a_cs is the light model ambient color, a_cm is the front 
    ambient material color, and e_cm is the front emissive material 
    color.  The "w" component of the program parameter variable is 
    filled with the alpha component of the front diffuse material color.  
    If a program parameter binding matches 
    "state.lightmodel.back.scenecolor", a similar back scene color, 
    computed using back-facing material properties, is used.  The front
    and back scene colors match the values that would be assigned to 
    vertices using conventional lighting if all lights were disabled.

    If a program parameter binding matches anything beginning with
    "state.lightprod[n]", the "x", "y", and "z" components of the 
    program parameter variable are filled with the "r", "g", and "b" 
    components, respectively, of the corresponding light product.  The 
    three light product components are the products of the corresponding 
    color components of the specified material property and the light 
    color of the specified light (see Table X.2.3).  The "w" component 
    of the program parameter variable is filled with the alpha component 
    of the specified material property.

    Light products depend on material properties, which can be changed 
    inside a Begin/End pair.  Such property changes are not guaranteed 
    to take effect until the following End command.  Program parameter 
    variables bound to light products whose corresponding material 
    property changes inside a Begin/End pair are undefined until the 
    following End command.


    Texture Environment Property Bindings

      Binding                    Components  Underlying State
      -------------------------  ----------  ----------------------------
      state.texenv[n].color      (r,g,b,a)   texture environment n color

      Table X.2.4:  Texture Environment Property Bindings.  "[n]" is 
      optional -- texture unit <n> is used if specified; texture unit 0 
      is used otherwise.

    If a program parameter binding matches "state.texenv[n].color", the 
    "x", "y", "z", and "w" components of the program parameter variable 
    are filled with the "r", "g", "b", and "a" components, respectively, 
    of the corresponding texture environment color.  Note that only
    "legacy" texture units, as queried by MAX_TEXTURE_UNITS, include 
    texture environment state.  Texture image units and texture 
    coordinate sets do not have associated texture environment state.


    Fog Property Bindings

      Binding                      Components  Underlying State
      ---------------------------  ----------  ----------------------------
      state.fog.color              (r,g,b,a)   RGB fog color (section 3.11)
      state.fog.params             (d,s,e,r)   fog density, linear start
                                               and end, and 1/(end-start)
                                               (section 3.11) 

      Table X.2.5:  Fog Property Bindings

    If a program parameter binding matches "state.fog.color", the "x", 
    "y", "z", and "w" components of the program parameter variable are 
    filled with the "r", "g", "b", and "a" components, respectively, of 
    the fog color (section 3.11).

    If a program parameter binding matches "state.fog.params", the "x", 
    "y", and "z" components of the program parameter variable are filled 
    with the fog density, linear fog start, and linear fog end 
    parameters (section 3.11), respectively.  The "w" component is 
    filled with 1/(end-start), where end and start are the linear fog 
    end and start parameters, respectively.


    Depth Property Bindings

      Binding                      Components  Underlying State
      ---------------------------  ----------  ----------------------------
      state.depth.range            (n,f,d,1)   Depth range near, far, and
                                               (far-near) (section 2.10.1)

      Table X.2.6:  Depth Property Bindings

    If a program parameter binding matches "state.depth.range", the "x" 
    and "y" components of the program parameter variable are filled with 
    the mappings of near and far clipping planes to window coordinates,
    respectively.  The "z" component is filled with the difference of
    the mappings of near and far clipping planes, far minus near.  The 
    "w" component is filled with 1.


    Matrix Property Bindings

      Binding                               Underlying State
      ------------------------------------  ---------------------------
      * state.matrix.modelview[n]           modelview matrix n
        state.matrix.projection             projection matrix
        state.matrix.mvp                    modelview-projection matrix
      * state.matrix.texture[n]             texture matrix n
        state.matrix.palette[n]             modelview palette matrix n
        state.matrix.program[n]             program matrix n

      Table X.2.7:  Base Matrix Property Bindings.  The "[n]" syntax 
      indicates a specific matrix number.  For modelview and texture 
      matrices, a matrix number is optional, and matrix zero will be 
      used if the matrix number is omitted.  These base bindings may 
      further be modified by a inverse/transpose selector and a row 
      selector.

    If the beginning of a program parameter binding matches any of the 
    matrix binding names listed in Table X.2.7, the binding corresponds 
    to a 4x4 matrix.  If the parameter binding is followed by 
    ".inverse", ".transpose", or ".invtrans" (<stateMatModifier> grammar 
    rule), the inverse, transpose, or transpose of the inverse, 
    respectively, of the matrix specified in Table X.2.7 is selected.  
    Otherwise, the matrix specified in Table X.2.7 is selected.  If the 
    specified matrix is poorly-conditioned (singular or nearly so), its 
    inverse matrix is undefined.  The binding name "state.matrix.mvp" 
    refers to the product of modelview matrix zero and the projection 
    matrix, defined as

       MVP = P * M0,

    where P is the projection matrix and M0 is modelview matrix zero.

    If the selected matrix is followed by ".row[<a>]" (matching the
    <stateMatrixRow> grammar rule), the "x", "y", "z", and "w" 
    components of the program parameter variable are filled with the 
    four entries of row <a> of the selected matrix.  In the example,

      PARAM m0 = state.matrix.modelview[1].row[0];
      PARAM m1 = state.matrix.projection.transpose.row[3];

    the variable "m0" is set to the first row (row 0) of modelview 
    matrix 1 and "m1" is set to the last row (row 3) of the transpose of 
    the projection matrix.

    For program parameter array bindings, multiple rows of the selected 
    matrix can be bound via the <stateMatrixRows> grammar rule.  If the 
    selected matrix binding is followed by ".row[<a>..<b>]", the result 
    is equivalent to specifying matrix rows <a> through <b>, in order.  
    A program will fail to load if <a> is greater than <b>.  If no row 
    selection is specified (<optMatrixRows> matches ""), matrix rows 0 
    through 3 are bound in order.  In the example,

      PARAM m2[] = { state.matrix.program[0].row[1..2] };
      PARAM m3[] = { state.matrix.program[0].transpose };

    the array "m2" has two entries, containing rows 1 and 2 of program 
    matrix zero, and "m3" has four entries, containing all four rows of 
    the transpose of program matrix zero.


    Program Parameter Arrays

    A program parameter array variable can be declared explicitly by 
    matching the <PARAM_multipleStmt> grammar rule.  Programs can 
    optionally specify the number of individual program parameters in 
    the array, using the <optArraySize> grammar rule.  Program parameter 
    arrays may not be declared implicity.

    Individual parameter variables in a program parameter array are 
    bound to GL state vectors or constant vectors as specified by the 
    grammar rule <paramMultInitList>.  Each individual parameter in the 
    array is bound in turn as described above.  

    The total number of entries in the array is equal to the number of
    parameters bound in the initializer list.  A fragment program that 
    specifies an array size (<optArraySize> matches <integer>) that does 
    not match the number of parameter bindings in the initialization 
    list will fail to load.

    Program parameter array variables may only be accessed using 
    absolute addressing by matching the <progParamArrayAbs> grammar 
    rule.  Array accesses are checked against the limits of the array.  
    If any fragment program instruction accesses a program parameter
    array with an out-of-range index (greater than or equal to the size 
    of the array), the fragment program will fail to load.

    Individual state vectors can have no more than one unique binding in 
    any given program.  The GL will automatically combine multiple 
    bindings of the same state vector into a single unique binding.


    3.11.3.3  Fragment Program Temporaries

    Fragment program temporary variables are a set of four-component
    floating-point vectors used to hold temporary results during 
    fragment program execution.  Temporaries do not persist between 
    program invocations, and are undefined at the beginning of each 
    fragment program invocation.

    Fragment program temporary variables can be declared explicitly 
    using the <TEMP_statement> grammar rule.  Each such statement can 
    declare one or more temporaries.  Fragment program temporary 
    variables can not be declared implicitly.


    3.11.3.4  Fragment Program Results

    Fragment program result variables are a set of four component 
    floating-point vectors used to hold the final results of a fragment 
    program.  Fragment program result variables are write-only during 
    fragment program execution.

    Fragment program result variables can be declared explicitly using 
    the <OUTPUT_statement> grammar rule, or implicitly using the
    <resultBinding> grammar rule in an executable instruction.  Each 
    fragment program result variable is bound to a fragment attribute 
    used in subsequent back-end processing.  The set of fragment program
    result variable bindings is given in Table X.3.

      Binding                        Components  Description
      -----------------------------  ----------  ----------------------------
      result.color                   (r,g,b,a)   color
      result.depth                   (*,*,d,*)   depth coordinate

      Table X.3:  Fragment Result Variable Bindings.  Components labeled 
      "*" are unused.

    If a result variable binding matches "result.color", updates to the 
    "x", "y", "z", and "w" components of the result variable modify the
    "r", "g", "b", and "a" components, respectively, of the fragment's
    output color.  If "result.color" is not both bound by the fragment 
    program and written by some instruction of the program, the output 
    color of the fragment program is undefined.

    If a result variable binding matches "result.depth", updates to the 
    "z" component of the result variable modify the fragment's output
    depth value.  If "result.depth" is not both bound by the fragment 
    program and written by some instruction of the program, the 
    interpolated depth value produced by rasterization is used as if 
    fragment program mode is not enabled.  Writes to any component of 
    depth other than the "z" component have no effect.


    3.11.3.5  Fragment Program Aliases

    Fragment programs can create aliases by matching the 
    <ALIAS_statement> grammar rule.  Aliases allow programs to use 
    multiple variable names to refer to a single underlying variable.  
    For example, the statement

      ALIAS var1 = var0

    establishes a variable name named "var1".  Subsequent references to 
    "var1" in the program text are treated as references to "var0".  The 
    left hand side of an ALIAS statement must be a new variable name, 
    and the right hand side must be an established variable name.

    Aliases are not considered variable declarations, so do not count 
    against the limits on the number of variable declarations allowed in 
    the program text.


    3.11.3.6  Fragment Program Resource Limits

    The fragment program execution environment provides implementation-
    dependent resource limits on the number of ALU instructions, texture
    instructions, total instructions (ALU or texture), temporary 
    variable declarations, program parameter bindings, or texture
    indirections.  A program that exceeds any of these resource limits 
    will fail to load.  The resource limits for fragment programs can be 
    queried by calling GetProgramiv (section 6.1.12) with a target of 
    FRAGMENT_PROGRAM_ARB.
    
    The limit on fragment program ALU instructions can be queried with 
    a <pname> of MAX_PROGRAM_ALU_INSTRUCTIONS_ARB, and must be at least 
    48.  Each ALU instruction in the program (matches of the 
    <ALUInstruction> grammar rule) counts against this limit.

    The limit on fragment program texture instructions can be queried 
    with a <pname> of MAX_PROGRAM_TEX_INSTRUCTIONS_ARB, and must be at 
    least 24.  Each texture instruction in the program (matches of the 
    <TexInstruction> grammar rule) counts against this limit.

    The limit on fragment program total instructions can be queried with 
    a <pname> of MAX_PROGRAM_INSTRUCTIONS_ARB, and must be at least 72.  
    Each instruction in the program (matching the <instruction> grammar 
    rule) counts against this limit.  Note that the limit on total
    instructions is not necessarily equal to the sum of the limits on
    ALU instructions and texture instructions.

    The limit on fragment program texture indirections can be queried 
    with a <pname> of MAX_PROGRAM_TEX_INDIRECTIONS_ARB, and must be at 
    least 4.  Texture indirections are described in 3.11.6.  If an
    implementation has no limit on texture indirections, the limit will
    be equal to the limit on texture instructions.

    The limit on fragment program temporary variable declarations can be 
    queried with a <pname> of MAX_PROGRAM_TEMPORARIES_ARB, and must be at 
    least 16.  Each temporary declared in the program, using the 
    <TEMP_statement> grammar rule, counts against this limit.  Aliases 
    of declared temporaries do not.
    
    The limit on fragment program attribute bindings can be queried with 
    a <pname> of MAX_PROGRAM_ATTRIBS_ARB and must be at least 10.  Each 
    distinct vertex attribute bound explicitly or implicitly in the 
    program counts against this limit; vertex attributes bound multiple 
    times count only once.

    The limit on fragment program parameter bindings can be queried with 
    a <pname> of MAX_PROGRAM_PARAMETERS_ARB, and must be at least 24.  
    Each distinct GL state vector bound explicitly or implicitly in the 
    program counts against this limit; GL state vectors bound multiple 
    times count only once.  Every other constant vector bound in the 
    program is counted if and only if an identical constant vector has 
    not already been counted.  Two constant vectors are considered 
    identical if the four component values are numerically equivalent.
    Recall that scalar constants bound in a program are treated as 
    vector constants with the scalar value replicated.

    In addition to the limits described above, the GL provides a similar 
    set of implementation-dependent native resource limits.  These 
    limits, specified in Section 6.1.12, provide guidance as to whether 
    the program is small enough to use a "native" mode where fragment 
    programs may be executed with higher performance.  The native 
    resource limits and usage counts are implementation-dependent and 
    may not exactly correspond to limits and counts described above.   
    A program's native resource consumption may be reduced by program 
    optimizations performed by the GL.  Native resource consumption may
    be increased due to emulation of instructions or any other program
    features not natively supported by an implementation.  Notably, an
    additional texture indirection may be consumed due to an 
    implementation's lack of native support for texture instructions 
    with source coordinate swizzles or parameter source coordinates, 
    which may require emulation by prepending ALU instructions.  An 
    implementation may also fail to natively support all combinations of 
    attributes described in Table X.1, even if the total number of
    bound attributes is fewer than the native attribute limit.  In this
    case the program is still considered to exceed the native resource
    limits, as queried by PROGRAM_UNDER_NATIVE_LIMITS_ARB (section 
    6.1.12).

    To assist in resource counting, the GL additionally provides 
    GetProgram queries to determine the resource usage and native 
    resource usage of the currently bound program, and to determine 
    whether the bound program exceeds any native resource limit.

    Programs that exceed any native resource limit may or may not load 
    depending on the implementation.


    3.11.4  Fragment Program Execution Environment

    If fragment program mode is enabled, the currently bound fragment 
    program is executed when any fragment is produced by rasterization.

    If fragment program mode is enabled and the currently bound program 
    object does not contain a valid fragment program, the error 
    INVALID_OPERATION will be generated by Begin, RasterPos, and any 
    command that implicitly calls Begin (e.g., DrawArrays).

    Fragment programs execute a sequence of instructions without
    branching.  Fragment programs begin by executing the first 
    instruction in the program, and execute instructions in the order 
    specified in the program until the last instruction is completed.
    
    There are 33 fragment program instructions.  The instructions and 
    their respective input and output parameters are summarized in 
    Table X.5.

      Instruction    Inputs  Output   Description
      -----------    ------  ------   --------------------------------
      ABS            v       v        absolute value
      ADD            v,v     v        add
      CMP            v,v,v   v        compare
      COS            s       ssss     cosine with reduction to [-PI,PI]
      DP3            v,v     ssss     3-component dot product
      DP4            v,v     ssss     4-component dot product
      DPH            v,v     ssss     homogeneous dot product
      DST            v,v     v        distance vector
      EX2            s       ssss     exponential base 2
      FLR            v       v        floor
      FRC            v       v        fraction
      KIL            v       v        kill fragment
      LG2            s       ssss     logarithm base 2
      LIT            v       v        compute light coefficients
      LRP            v,v,v   v        linear interpolation
      MAD            v,v,v   v        multiply and add
      MAX            v,v     v        maximum
      MIN            v,v     v        minimum
      MOV            v       v        move
      MUL            v,v     v        multiply
      POW            s,s     ssss     exponentiate
      RCP            s       ssss     reciprocal
      RSQ            s       ssss     reciprocal square root
      SCS            s       ss--     sine/cosine without reduction
      SGE            v,v     v        set on greater than or equal
      SIN            s       ssss     sine with reduction to [-PI,PI]
      SLT            v,v     v        set on less than
      SUB            v,v     v        subtract
      SWZ            v       v        extended swizzle
      TEX            v,u,t   v        texture sample
      TXB            v,u,t   v        texture sample with bias
      TXP            v,u,t   v        texture sample with projection
      XPD            v,v     v        cross product

      Table X.5:  Summary of fragment program instructions.  "v" 
      indicates a floating-point vector input or output, "s" indicates a 
      floating-point scalar input, "ssss" indicates a scalar output 
      replicated across a 4-component result vector, "ss--" indicates
      two scalar outputs in the first two components, "u" indicates a 
      texture image unit identifier, and "t" indicates a texture target.


    3.11.4.1  Fragment Program Operands

    Most fragment program instructions operate on floating-point vectors 
    or scalars, as indicated by the grammar rules <vectorSrcReg> and
    <scalarSrcReg>, respectively.

    Vector and scalar operands can be obtained from fragment attribute, 
    program parameter, or temporary registers, as indicated by the 
    <srcReg> rule.  For scalar operands, a single vector component is 
    selected by the <scalarSuffix> rule, where the characters "x", "y", 
    "z", and "w", or "r", "g", "b", and "a" select the first, second, 
    third, and fourth components, respectively, of the vector.

    Vector operands can be swizzled according to the <optionalSuffix> 
    rule.  In its most general form, the <optionalSuffix> rule matches
    the pattern ".????" where each question mark is replaced with one of
    "x", "y", "z", "w", "r", "g", "b", or "a".  For such patterns, the 
    first, second, third, and fourth components of the operand are taken 
    from the vector components named by the first, second, third, and 
    fourth character of the pattern, respectively.  For example, if the 
    swizzle suffix is ".yzzx" or ".gbbr" and the specified source 
    contains {2,8,9,0}, the swizzled operand used by the instruction is 
    {8,9,9,2}.

    If the <optionalSuffix> rule matches "", it is treated as though it 
    were ".xyzw".  If the <optionalSuffix> rule matches (ignoring 
    whitespace) ".x", ".y", ".z", or ".w", these are treated the same as 
    ".xxxx", ".yyyy", ".zzzz", and ".wwww" respectively.  Likewise, if
    the <optionalSuffix> rule matches ".r", ".g", ".b", or ".a", these 
    are treated the same as ".rrrr", ".gggg", ".bbbb", and ".aaaa" 
    respectively.

    Floating-point scalar or vector operands can optionally be negated
    according to the <optionalSign> rule in <scalarSrcReg> and
    <vectorSrcReg>.  If the <optionalSign> matches "-", each operand or
    operand component is negated.

    The following pseudo-code spells out the operand generation process.  
    In the example, "float" is a floating-point scalar type, while 
    "floatVec" is a four-component vector.  "source" refers to the 
    register used for the operand, matching the <srcReg> rule.  "negate" 
    is TRUE if the <optionalSign> rule in <scalarSrcReg> or 
    <vectorSrcReg> matches "-" and FALSE otherwise.  The ".c***", 
    ".*c**", ".**c*", ".***c" modifiers refer to the x, y, z, and w 
    components obtained by the swizzle operation; the ".c" modifier
    refers to the single component selected for a scalar load.

      floatVec VectorLoad(floatVec source)
      {
          floatVec operand;

          operand.x = source.c***;
          operand.y = source.*c**;
          operand.z = source.**c*;
          operand.w = source.***c;
          if (negate) {
             operand.x = -operand.x;
             operand.y = -operand.y;
             operand.z = -operand.z;
             operand.w = -operand.w;
          }

          return operand;
      }

      float ScalarLoad(floatVec source) 
      {
          float operand;

          operand = source.c;
          if (negate) {
            operand = -operand;
          }

          return operand;
      }


    3.11.4.2  Fragment Program Parameter Arrays

    A fragment program can load a single element of a program parameter 
    array using only absolute addressing.  Program parameter arrays are 
    accessed when the <progParamArrayAbs> rule is matched.  The offset 
    of the selected entry in the array is given by the number matching 
    <progParamRegNum>.  If the offset exceeds the size of the 
    array, the results of the access are undefined, but may not lead to
    program or GL termination.


    3.11.4.3  Fragment Program Destination Register Update

    Fragment program instructions write a 4-component result vector to a
    single temporary or fragment result register.  Writes to individual 
    components of the destination register are controlled by individual 
    component write masks specified as part of the instruction.  
    Optional clamping of each component of the destination register to 
    the range [0,1] is controlled by an opcode modifier.

    The component write mask is specified by the <optionalMask> rule 
    found in the <maskedDstReg> rule.  If the optional mask is "", all 
    components are enabled.  Otherwise, the optional mask names the 
    individual components to enable.  The characters "x", "y", "z", and 
    "w", or "r", "g", "b", and "a" match the first, second, third, and 
    fourth components, respectively.  For example, an optional mask of 
    ".xzw" indicates that the x, z, and w components should be enabled 
    for writing but the y component should not.  The grammar requires 
    that the destination register mask components must be listed in 
    "xyzw", or "rgba" order.  Component names from one set (xyzw or 
    rgba) cannot be mixed with component names from another set.  For 
    example, ".rgw" is not a valid writemask.

    Each component of the destination register is updated with the 
    result of the fragment program instruction if and only if the 
    component is enabled for writes by the component write mask.  
    Otherwise, the component of the destination register remains 
    unchanged.

    If the instruction opcode has the "_SAT" suffix, requesting 
    saturated result vectors, each component of the result vector 
    enabled in the writemask is clamped to the range [0,1] before being 
    updated in the destination register.

    The following pseudocode illustrates the process of writing a result
    vector to the destination register.  In the pseudocode, "instrmask" 
    refers to the component write mask given by the <optionalMask> rule.  
    "clamp" is TRUE if the instruction specifies that the result should
    be clamped.  "result" and "destination" refer to the result vector 
    and the register selected by <dstReg>, respectively.

      void UpdateDestination(floatVec destination, floatVec result)
      {
          floatVec merged;

          // Clamp the result vector components to [0,1], if requested.
          if (instrClamp) {
              if (result.x < 0)      result.x = 0;
              else if (result.x > 1) result.x = 1;
              if (result.y < 0)      result.y = 0;
              else if (result.y > 1) result.y = 1;
              if (result.z < 0)      result.z = 0;
              else if (result.z > 1) result.z = 1;
              if (result.w < 0)      result.w = 0;
              else if (result.w > 1) result.w = 1;
          }

          // Merge the converted result into the destination register,
          // under control of the compile-time write mask.
          merged = destination;
          if (instrMask.x) {
              merged.x = result.x;
          }
          if (instrMask.y) {
              merged.y = result.y;
          }
          if (instrMask.z) {
              merged.z = result.z;
          }
          if (instrMask.w) {
              merged.w = result.w;
          }

          // Write out the new destination register.
          destination = merged;
      }


    3.11.4.4  Fragment Program Result Processing

    As a fragment program executes, it will write to either one or two 
    result registers that are mapped to the fragment's color and depth.

    The fragment's color components are first clamped to the range [0,1] 
    then converted to fixed point as in section 2.13.9.  If the fragment
    program does not write result.color, the color will be undefined in 
    subsequent stages.

    If the fragment program contains an instruction to write to
    result.depth, the fragment's depth is replaced by the value of the
    "z" component of result.depth.  This z value is first clamped to the
    range [0,1] then converted to fixed-point as if it were a window z
    value (section 2.10.1).  If the fragment program does not write 
    result.depth, the fragment's original depth is unmodified.


    3.11.4.5  Fragment Program Options

    The <optionSequence> grammar rule provides a mechanism for programs 
    to indicate that one or more extended language features are used by 
    the program.  All program options used by the program must be 
    declared at the beginning of the program string.  Each program 
    option specified in a program string will modify the syntactic or 
    semantic rules used to interpet the program and the execution 
    environment used to execute the program.  Program options not 
    present in the program string are ignored, even if they are 
    supported by the GL.

    The <identifier> token in the <option> rule must match the name of a
    program option supported by the implementation.  To avoid option 
    name conflicts, option identifiers are required to begin with a 
    vendor prefix.  A program will fail to load if it specifies a 
    program option not supported by the GL.

    Fragment program options should confine their semantic changes to 
    the domain of fragment programs.  Support for a fragment program 
    option should not change the specification and behavior of fragment 
    programs not requesting use of that option.


    3.11.4.5.1  Fog Application Fragment Program Options

    If a fragment program specifies one of the options "ARB_fog_exp", 
    "ARB_fog_exp2", or "ARB_fog_linear", the program will apply fog to 
    the program's final clamped color using a fog mode of EXP, EXP2, or 
    LINEAR, respectively, as described in section 3.10.

    When a fog option is specified in a fragment program, semantic 
    restrictions are added to indicate that a fragment program 
    will fail to load if the number of temporaries it contains exceeds 
    the implementation-dependent limit minus 1, if the number of 
    attributes it contains exceeds the implementation-dependent limit
    minus 1, or if the number of parameters it contains exceeds the 
    implementation-dependent limit minus 2.

    Additionally, when the ARB_fog_exp option is specified in a fragment
    program, a semantic restriction is added to indicate that a fragment
    program will fail to load if the number of instructions or ALU 
    instructions it contains exceeds the implementation-dependent limit 
    minus 3.  When the ARB_fog_exp2 option is specified in a fragment
    program, a semantic restriction is added to indicate that a fragment
    program will fail to load if the number of instructions or ALU 
    instructions it contains exceeds the implementation-dependent limit 
    minus 4.  When the ARB_fog_linear option is specified in a fragment
    program, a semantic restriction is added to indicate that a fragment
    program will fail to load if the number of instructions or ALU 
    instructions it contains exceeds the implementation-dependent limit 
    minus 2.

    Only one fog application option may be specified by any given 
    fragment program.  A fragment program that specifies more than one 
    of the program options "ARB_fog_exp", "ARB_fog_exp2", and 
    "ARB_fog_linear", will fail to load.


    3.11.4.5.2  Precision Hint Options

    Fragment program computations are carried out at an implementation-
    dependent precision.  However, some implementations may be able to
    perform fragment program computations at more than one precision, 
    and may be able to trade off computation precision for performance.  

    If a fragment program specifies the "ARB_precision_hint_fastest" 
    program option, implementations should select precision to minimize 
    program execution time, with possibly reduced precision.  If a 
    fragment program specifies the "ARB_precision_hint_nicest" program 
    option, implementations should maximize the precision, with possibly 
    increased execution time.

    Only one precision control option may be specified by any given 
    fragment program.  A fragment program that specifies both the
    "ARB_precision_hint_fastest" and "ARB_precision_hint_nicest" program
    options will fail to load.


    3.11.5  Fragment Program ALU Instruction Set

    The following sections describe the set of supported fragment 
    program instructions.  Each section contains pseudocode describing
    the instruction.  Instructions will have up to three operands,
    referred to as "op0", "op1", and "op2".  The operands are loaded 
    using the mechanisms specified in section 3.11.4.1.  The variables 
    "tmp", "tmp0", "tmp1", and "tmp2" describe scalars or vectors used 
    to hold intermediate results in the instruction.  Instructions will 
    generate a result vector called "result".  The result vector is then 
    written to the destination register specified in the instruction as 
    described in section 3.11.4.3.
    

    3.11.5.1  ABS:  Absolute Value

    The ABS instruction performs a component-wise absolute value 
    operation on the single operand to yield a result vector.

      tmp = VectorLoad(op0); 
      result.x = fabs(tmp.x);
      result.y = fabs(tmp.y);
      result.z = fabs(tmp.z);
      result.w = fabs(tmp.w);


    3.11.5.2  ADD:  Add

    The ADD instruction performs a component-wise add of the two 
    operands to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.x + tmp1.x;
      result.y = tmp0.y + tmp1.y;
      result.z = tmp0.z + tmp1.z;
      result.w = tmp0.w + tmp1.w;

    The following rules apply to addition:

      1. <x> + <y> == <y> + <x>, for all <x> and <y>.
      2. <x> + 0.0 == <x>, for all <x>.


    3.11.5.3  CMP: Compare

    The CMP instructions performs a component-wise comparison of the 
    first operand against zero, and copies the values of the second or
    third operands based on the results of the compare.
    
      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      tmp2 = VectorLoad(op2);
      result.x = (tmp0.x < 0.0) ? tmp1.x : tmp2.x;
      result.y = (tmp0.y < 0.0) ? tmp1.y : tmp2.y;
      result.z = (tmp0.z < 0.0) ? tmp1.z : tmp2.z;
      result.w = (tmp0.w < 0.0) ? tmp1.w : tmp2.w;
 
   
    3.11.5.4  COS:  Cosine

    The COS instruction approximates the trigonometric cosine of the 
    angle specified by the scalar operand and replicates it to all four 
    components of the result vector.  The angle is specified in radians
    and does not have to be in the range [-PI,PI].

      tmp = ScalarLoad(op0);
      result.x = ApproxCosine(tmp);
      result.y = ApproxCosine(tmp);
      result.z = ApproxCosine(tmp);
      result.w = ApproxCosine(tmp);


    3.11.5.5  DP3:  Three-Component Dot Product

    The DP3 instruction computes a three-component dot product of the 
    two operands (using the first three components) and replicates the 
    dot product to all four components of the result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + (tmp0.z * tmp1.z);
      result.x = dot;
      result.y = dot;
      result.z = dot;
      result.w = dot;


    3.11.5.6  DP4:  Four-Component Dot Product

    The DP4 instruction computes a four-component dot product of the two
    operands and replicates the dot product to all four components of 
    the result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1):
      dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + 
            (tmp0.z * tmp1.z) + (tmp0.w * tmp1.w);
      result.x = dot;
      result.y = dot;
      result.z = dot;
      result.w = dot;


    3.11.5.7  DPH:  Homogeneous Dot Product

    The DPH instruction computes a three-component dot product of the 
    two operands (using the x, y, and z components), adds the w 
    component of the second operand, and replicates the sum to all four 
    components of the result vector.  This is equivalent to a four-
    component dot product where the w component of the first operand is 
    forced to 1.0.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1):
      dot = (tmp0.x * tmp1.x) + (tmp0.y * tmp1.y) + 
            (tmp0.z * tmp1.z) + tmp1.w;
      result.x = dot;
      result.y = dot;
      result.z = dot;
      result.w = dot;


    3.11.5.8  DST:  Distance Vector

    The DST instruction computes a distance vector from two specially-
    formatted operands.  The first operand should be of the form [NA, 
    d^2, d^2, NA] and the second operand should be of the form [NA, 1/d, 
    NA, 1/d], where NA values are not relevant to the calculation and d 
    is a vector length.  If both vectors satisfy these conditions, the 
    result vector will be of the form [1.0, d, d^2, 1/d].

    The exact behavior is specified in the following pseudo-code:

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = 1.0;
      result.y = tmp0.y * tmp1.y;
      result.z = tmp0.z;
      result.w = tmp1.w;

    Given an arbitrary vector, d^2 can be obtained using the DP3 
    instruction (using the same vector for both operands) and 1/d can be 
    obtained from d^2 using the RSQ instruction.

    This distance vector is useful for per-fragment light attenuation
    calculations:  a DP3 operation using the distance vector and an
    attenuation constants vector as operands will yield the attenuation
    factor.


    3.11.5.9  EX2:  Exponential Base 2

    The EX2 instruction approximates 2 raised to the power of the scalar
    operand and replicates the approximation to all four components of 
    the result vector.

      tmp = ScalarLoad(op0);
      result.x = Approx2ToX(tmp);
      result.y = Approx2ToX(tmp);
      result.z = Approx2ToX(tmp);
      result.w = Approx2ToX(tmp);


    3.11.5.10  FLR:  Floor

    The FLR instruction performs a component-wise floor operation on the
    operand to generate a result vector.  The floor of a value is 
    defined as the largest integer less than or equal to the value.  The 
    floor of 2.3 is 2.0; the floor of -3.6 is -4.0.

      tmp = VectorLoad(op0);
      result.x = floor(tmp.x);
      result.y = floor(tmp.y);
      result.z = floor(tmp.z);
      result.w = floor(tmp.w);


    3.11.5.11  FRC:  Fraction

    The FRC instruction extracts the fractional portion of each 
    component of the operand to generate a result vector.  The 
    fractional portion of a component is defined as the result after 
    subtracting off the floor of the component (see FLR), and is always 
    in the range [0.0, 1.0).

    For negative values, the fractional portion is NOT the number 
    written to the right of the decimal point -- the fractional portion 
    of -1.7 is not 0.7 -- it is 0.3.  0.3 is produced by subtracting the 
    floor of -1.7 (-2.0) from -1.7.

      tmp = VectorLoad(op0);
      result.x = fraction(tmp.x);
      result.y = fraction(tmp.y);
      result.z = fraction(tmp.z);
      result.w = fraction(tmp.w);


    3.11.5.12  LG2:  Logarithm Base 2

    The LG2 instruction approximates the base 2 logarithm of the scalar
    operand and replicates it to all four components of the result 
    vector.

      tmp = ScalarLoad(op0);
      result.x = ApproxLog2(tmp);
      result.y = ApproxLog2(tmp);
      result.z = ApproxLog2(tmp);
      result.w = ApproxLog2(tmp);

    If the scalar operand is zero or negative, the result is undefined.


    3.11.5.13  LIT:  Light Coefficients

    The LIT instruction accelerates per-fragment lighting by computing 
    lighting coefficients for ambient, diffuse, and specular light 
    contributions.  The "x" component of the single operand is assumed 
    to hold a diffuse dot product (n dot VP_pli, as in the vertex 
    lighting equations in Section 2.13.1).  The "y" component of the 
    operand is assumed to hold a specular dot product (n dot h_i).  The 
    "w" component of the operand is assumed to hold the specular 
    exponent of the material (s_rm), and is clamped to the range (-128, 
    +128) exclusive.

    The "x" component of the result vector receives the value that 
    should be multiplied by the ambient light/material product (always 
    1.0).  The "y" component of the result vector receives the value 
    that should be multiplied by the diffuse light/material product 
    (n dot VP_pli).  The "z" component of the result vector receives the 
    value that should be multiplied by the specular light/material 
    product (f_i * (n dot h_i) ^ s_rm).  The "w" component of the result 
    is the constant 1.0.

    Negative diffuse and specular dot products are clamped to 0.0, as is 
    done in the standard per-vertex lighting operations.  In addition, 
    if the diffuse dot product is zero or negative, the specular 
    coefficient is forced to zero.

      tmp = VectorLoad(op0);
      if (tmp.x < 0) tmp.x = 0;
      if (tmp.y < 0) tmp.y = 0;
      if (tmp.w < -(128.0-epsilon)) tmp.w = -(128.0-epsilon);
      else if (tmp.w > 128-epsilon) tmp.w = 128-epsilon;
      result.x = 1.0;
      result.y = tmp.x;
      result.z = (tmp.x > 0) ? RoughApproxPower(tmp.y, tmp.w) : 0.0;
      result.w = 1.0;

    The exponentiation approximation function may be defined in terms of 
    the base 2 exponentiation and logarithm approximation operations in 
    the EX2 and LG2 instructions, where

      ApproxPower(a,b) = ApproxExp2(b * ApproxLog2(a)).

    In particular, the approximation may not be any more accurate than 
    the underlying EX2 and LG2 operations.

    Also, since 0^0 is defined to be 1, RoughApproxPower(0.0, 0.0) will
    produce 1.0.


    3.11.5.14  LRP: Linear Interpolation

    The LRP instruction performs a component-wise linear interpolation 
    between the second and third operands using the first operand as the
    blend factor.
    
      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      tmp2 = VectorLoad(op2);
      result.x = tmp0.x * tmp1.x + (1 - tmp0.x) * tmp2.x;
      result.y = tmp0.y * tmp1.y + (1 - tmp0.y) * tmp2.y;
      result.z = tmp0.z * tmp1.z + (1 - tmp0.z) * tmp2.z;
      result.w = tmp0.w * tmp1.w + (1 - tmp0.w) * tmp2.w;


    3.11.5.15  MAD:  Multiply and Add

    The MAD instruction performs a component-wise multiply of the first two
    operands, and then does a component-wise add of the product to the 
    third operand to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      tmp2 = VectorLoad(op2);
      result.x = tmp0.x * tmp1.x + tmp2.x;
      result.y = tmp0.y * tmp1.y + tmp2.y;
      result.z = tmp0.z * tmp1.z + tmp2.z;
      result.w = tmp0.w * tmp1.w + tmp2.w;

    The multiplication and addition operations in this instruction are 
    subject to the same rules as described for the MUL and ADD 
    instructions.


    3.11.5.16  MAX:  Maximum

    The MAX instruction computes component-wise maximums of the values 
    in the two operands to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x > tmp1.x) ? tmp0.x : tmp1.x;
      result.y = (tmp0.y > tmp1.y) ? tmp0.y : tmp1.y;
      result.z = (tmp0.z > tmp1.z) ? tmp0.z : tmp1.z;
      result.w = (tmp0.w > tmp1.w) ? tmp0.w : tmp1.w;


    3.11.5.17  MIN:  Minimum

    The MIN instruction computes component-wise minimums of the values 
    in the two operands to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x > tmp1.x) ? tmp1.x : tmp0.x;
      result.y = (tmp0.y > tmp1.y) ? tmp1.y : tmp0.y;
      result.z = (tmp0.z > tmp1.z) ? tmp1.z : tmp0.z;
      result.w = (tmp0.w > tmp1.w) ? tmp1.w : tmp0.w;


    3.11.5.18  MOV:  Move

    The MOV instruction copies the value of the operand to yield a 
    result vector.

      result = VectorLoad(op0);


    3.11.5.19  MUL:  Multiply

    The MUL instruction performs a component-wise multiply of the two 
    operands to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.x * tmp1.x;
      result.y = tmp0.y * tmp1.y;
      result.z = tmp0.z * tmp1.z;
      result.w = tmp0.w * tmp1.w;

    The following rules apply to multiplication:

      1. <x> * <y> == <y> * <x>, for all <x> and <y>.
      2. +/-0.0 * <x> = +/-0.0, at least for all <x> that correspond to
         representable numbers (IEEE "not a number" and "infinity" 
         encodings may be exceptions).
      3. +1.0 * <x> = <x>, for all <x>.

    Multiplication by zero and one should be invariant, as it may be 
    used to evaluate conditional expressions without branching.


    3.11.5.20  POW:  Exponentiate

    The POW instruction approximates the value of the first scalar 
    operand raised to the power of the second scalar operand and 
    replicates it to all four components of the result vector.

      tmp0 = ScalarLoad(op0);
      tmp1 = ScalarLoad(op1);
      result.x = ApproxPower(tmp0, tmp1);
      result.y = ApproxPower(tmp0, tmp1);
      result.z = ApproxPower(tmp0, tmp1);
      result.w = ApproxPower(tmp0, tmp1);

    The exponentiation approximation function may be implemented using 
    the base 2 exponentiation and logarithm approximation operations in 
    the EX2 and LG2 instructions.  In particular,

      ApproxPower(a,b) = ApproxExp2(b * ApproxLog2(a)).

    Note that a logarithm may be involved even for cases where the 
    exponent is an integer.  This means that it may not be possible to 
    exponentiate correctly with a negative base.  In constrast, it is 
    possible in a "normal" mathematical formulation to raise negative 
    numbers to integral powers (e.g., (-3)^2== 9, and (-0.5)^-2==4).


    3.11.5.21  RCP:  Reciprocal

    The RCP instruction approximates the reciprocal of the scalar 
    operand and replicates it to all four components of the result 
    vector.

      tmp = ScalarLoad(op0);
      result.x = ApproxReciprocal(tmp);
      result.y = ApproxReciprocal(tmp);
      result.z = ApproxReciprocal(tmp);
      result.w = ApproxReciprocal(tmp);

    The following rule applies to reciprocation:

      1. ApproxReciprocal(+1.0) = +1.0.


    3.11.5.22  RSQ:  Reciprocal Square Root

    The RSQ instruction approximates the reciprocal of the square root 
    of the absolute value of the scalar operand and replicates it to all 
    four components of the result vector.

      tmp = fabs(ScalarLoad(op0));
      result.x = ApproxRSQRT(tmp);
      result.y = ApproxRSQRT(tmp);
      result.z = ApproxRSQRT(tmp);
      result.w = ApproxRSQRT(tmp);


    3.11.5.23  SCS:  Sine/Cosine

    The SCS instruction approximates the trigonometric sine and cosine
    of the angle specified by the scalar operand and places the cosine 
    in the x component and the sine in the y component of the result 
    vector.  The z and w components of the result vector are undefined.
    The angle is specified in radians and must be in the range [-PI,PI].

      tmp = ScalarLoad(op0);
      result.x = ApproxCosine(tmp);
      result.y = ApproxSine(tmp);

    If the scalar operand is not in the range [-PI,PI], the result
    vector is undefined.


    3.11.5.24  SGE:  Set On Greater or Equal Than

    The SGE instruction performs a component-wise comparison of the two
    operands.  Each component of the result vector is 1.0 if the 
    corresponding component of the first operands is greater than or 
    equal that of the second, and 0.0 otherwise.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x >= tmp1.x) ? 1.0 : 0.0;
      result.y = (tmp0.y >= tmp1.y) ? 1.0 : 0.0;
      result.z = (tmp0.z >= tmp1.z) ? 1.0 : 0.0;
      result.w = (tmp0.w >= tmp1.w) ? 1.0 : 0.0;


    3.11.5.25  SIN:  Sine

    The SIN instruction approximates the trigonometric sine of the angle
    specified by the scalar operand and replicates it to all four 
    components of the result vector.  The angle is specified in radians
    and does not have to be in the range [-PI,PI].

      tmp = ScalarLoad(op0);
      result.x = ApproxSine(tmp);
      result.y = ApproxSine(tmp);
      result.z = ApproxSine(tmp);
      result.w = ApproxSine(tmp);


    3.11.5.26  SLT:  Set On Less Than

    The SLT instruction performs a component-wise comparison of the two
    operands.  Each component of the result vector is 1.0 if the 
    corresponding component of the first operand is less than that of 
    the second, and 0.0 otherwise.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = (tmp0.x < tmp1.x) ? 1.0 : 0.0;
      result.y = (tmp0.y < tmp1.y) ? 1.0 : 0.0;
      result.z = (tmp0.z < tmp1.z) ? 1.0 : 0.0;
      result.w = (tmp0.w < tmp1.w) ? 1.0 : 0.0;


    3.11.5.27  SUB:  Subtract

    The SUB instruction performs a component-wise subtraction of the 
    second operand from the first to yield a result vector.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.x - tmp1.x;
      result.y = tmp0.y - tmp1.y;
      result.z = tmp0.z - tmp1.z;
      result.w = tmp0.w - tmp1.w;


    3.11.5.28  SWZ:  Extended Swizzle

    The SWZ instruction loads the single vector operand, and performs a
    swizzle operation more powerful than that provided for loading 
    normal vector operands to yield an instruction vector.

    After the operand is loaded, the "x", "y", "z", and "w" components 
    of the result vector are selected by the first, second, third, and 
    fourth matches of the <xyzwExtSwizComp> or <rgbaExtSwizComp> pattern 
    in the <extendedSwizzle> rule.

    A result component can be selected from any of the four components 
    of the operand or the constants 0.0 and 1.0.  The result component 
    can also be optionally negated.  The following pseudocode describes 
    the component selection method.  "operand" refers to the vector 
    operand.  "select" is an enumerant where the values ZERO, ONE, X, Y,
    Z, and W correspond to the <xyzwExtSwizSel> rule matching "0", "1", "x", 
    "y", "z", and "w", respectively, or the <rgbaExtSwizSel> rule
    matching "0", 1", "r", "g", "b", and "a", respectively.  "negate" is 
    TRUE if and only if the <optionalSign> rule in <xyzwExtSwizComp> 
    or <rgbaExtSwizComp> matches "-".

      float ExtSwizComponent(floatVec operand, enum select, boolean negate)
      {
          float result;
          switch (select) {
            case ZERO:  result = 0.0; break;
            case ONE:   result = 1.0; break;
            case X:     result = operand.x; break;
            case Y:     result = operand.y; break;
            case Z:     result = operand.z; break;
            case W:     result = operand.w; break;
          }
          if (negate) {
            result = -result;
          }
          return result;
      }

    The entire extended swizzle operation is then defined using the 
    following pseudocode:

      tmp = VectorLoad(op0);
      result.x = ExtSwizComponent(tmp, xSelect, xNegate);
      result.y = ExtSwizComponent(tmp, ySelect, yNegate);
      result.z = ExtSwizComponent(tmp, zSelect, zNegate);
      result.w = ExtSwizComponent(tmp, wSelect, wNegate);

    "xSelect", "xNegate", "ySelect", "yNegate", "zSelect", "zNegate",
    "wSelect", and "wNegate" correspond to the "select" and "negate" 
    values above for the four <xyzwExtSwizComp> or <rgbaExtSwizComp>
    matches.  

    Since this instruction allows for component selection and negation 
    for each individual component, the grammar does not allow the use of 
    the normal swizzle and negation operations allowed for vector 
    operands in other instructions.


    3.11.5.29  XPD:  Cross Product

    The XPD instruction computes the cross product using the first three
    components of its two vector operands to generate the x, y, and z
    components of the result vector.  The w component of the result 
    vector is undefined.

      tmp0 = VectorLoad(op0);
      tmp1 = VectorLoad(op1);
      result.x = tmp0.y * tmp1.z - tmp0.z * tmp1.y;
      result.y = tmp0.z * tmp1.x - tmp0.x * tmp1.z;
      result.z = tmp0.x * tmp1.y - tmp0.y * tmp1.x;


    3.11.6  Fragment Program Texture Instruction Set

    The first three texture instructions described below specify the 
    mapping of 4-tuple vectors to colors of an image.  The sampling of 
    the texture works as described in section 3.8, except that texture 
    environments and texture functions are not applicable, and the
    texture enables hierarchy is replaced by explicit references to
    the desired texture target (i.e., 1D, 2D, 3D, cube map, rectangle).  
    These texture instructions specify how the 4-tuple is mapped into 
    the coordinates used for sampling.  The following function is used 
    to describe the texture sampling in the descriptions below:

      vec4 TextureSample(float s, float t, float r, float lodBias,
                         int texImageUnit, enum texTarget);

    Note that not all three texture coordinates, s, t, and r, are
    used by all texture targets.  In particular, 1D texture targets only
    use the s component, and 2D and rectangle (non-power-of-two) texture
    targets only use the s and t components.  The descriptions of the
    texture instructions below supply all three components, as would be
    the case with 3D or cube map targets.

    If a fragment program samples from a texture target on a texture
    image unit where the bound texture object is not complete, as 
    defined in section 3.8.9, the result will be the vector 
    (R, G, B, A) = (0, 0, 0, 1).

    A fragment program will fail to load if it attempts to sample from
    multiple texture targets on the same texture image unit.  For 
    example, the following program would fail to load:

      !!ARBfp1.0
      TEX result.color, fragment.texcoord[0], texture[0], 2D;
      TEX result.depth, fragment.texcoord[1], texture[0], 3D;
      END

    The fourth texture instruction described below, KIL, does not sample
    from a texture, but rather prevents further processing of the 
    current fragment if any component of its 4-tuple vector is less than
    zero.

    A dependent texture instruction is one that samples using a texture
    coordinate residing in a temporary, rather than in an attribute or
    a parameter.  A program may have a chain of dependent texture
    instructions, where the result of the first texture instruction is 
    used as the coordinate for a second texture instruction, which is in 
    turn used as the coordinate for a third texture instruction, and so 
    on.  Each node in this chain is termed an indirection, and can be 
    thought of as a set of texture samples that execute in parallel
    followed by a sequence of ALU instructions.

    Some implementations may have limitations on how long the dependency 
    chain may be, and so indirections are counted as a resource just
    like instructions or temporaries are counted.  All programs have at 
    least one indirection, or one node in this chain, even if the 
    program performs no texture operation.  Each instruction encountered
    is included in this node until a texture instruction is encountered

      - whose texture coordinate is a temporary that has been previously 
        written in the current node; or

      - whose result vector is a temporary that is also the operand or 
        result vector of a previous ALU instruction in the current node.

    A new node is then started, including the texture instruction and 
    all subsequent instructions, and the process repeats for all 
    instructions in the program.  Note that for simplicity in counting, 
    result writemasks and operand suffixes are not taken into 
    consideration when counting indirections.


    3.11.6.1  TEX: Map coordinate to color

    The TEX instruction takes the first three components of 
    its source vector, and maps them to s, t, and r.  These coordinates 
    are used to sample from the specified texture target on the 
    specified texture image unit in a manner consistent with its 
    parameters.  The resulting sample is mapped to RGBA as described in 
    table 3.21 and written to the result vector.

      tmp = VectorLoad(op0);
      result = TextureSample(tmp.x, tmp.y, tmp.z, 0.0, op1, op2);
   

    3.11.6.2  TXP: Project coordinate and map to color

    The TXP instruction divides the first three components of its source 
    vector by the fourth component and maps the results to s, t, and r.  
    These coordinates are used to sample from the specified texture
    target on the specified texture image unit in a manner consistent 
    with its parameters.  The resulting sample is mapped to RGBA as 
    described in table 3.21 and written to the result vector.  If the 
    value of the fourth component of the source vector is less than or 
    equal to zero, the result vector is undefined.

      tmp = VectorLoad(op0);
      tmp.x = tmp.x / tmp.w;
      tmp.y = tmp.y / tmp.w;
      tmp.z = tmp.z / tmp.w;
      result = TextureSample(tmp.x, tmp.y, tmp.z, 0.0, op1, op2);


    3.11.6.3  TXB: Map coordinate to color while biasing its LOD

    The TXB instruction takes the first three components of its source 
    vector and maps them to s, t, and r.  These coordinates are used to 
    sample from the specified texture target on the specified texture
    image unit in a manner consistent with its parameters.  
    Additionally, the fourth component of the source vector is applied 
    to equation 3.14 as fragment_bias below to further bias the level of 
    detail.
    
     lambda'(x,y) = log2[p(x,y)] + 
                    clamp(texobj_bias + texunit_bias + fragment_bias)
    
    The resulting sample is mapped to RGBA as described in table 3.21 
    and written to the result vector.

      tmp = VectorLoad(op0);
      result = TextureSample(tmp.x, tmp.y, tmp.z, tmp.w, op1, op2);


    3.11.6.4  KIL: Kill fragment

    Rather than mapping a coordinate set to a color, this function
    prevents a fragment from receiving any future processing.  If any
    component of its source vector is negative, the processing of this 
    fragment will be discontinued and no further outputs to this 
    fragment will occur.  Subsequent stages of the GL pipeline will be 
    skipped for this fragment.

      tmp = VectorLoad(op0);
      if ((tmp.x < 0) || (tmp.y < 0) || 
          (tmp.z < 0) || (tmp.w < 0))
      {
          exit;
      }


    3.11.7  Program Matrices

    In addition to GL's conventional matrices, several additional 
    program matrices are available for use as program parameters.  These 
    matrices have names of the form MATRIX<i>_ARB where <i> is between 
    zero and <n>-1 where <n> is the value of the implementation-
    dependent constant MAX_PROGRAM_MATRICES_ARB.  The MATRIX<i>_ARB 
    constants obey MATRIX<i>_ARB = MATRIX0_ARB + <i>.  The value of 
    MAX_PROGRAM_MATRICES_ARB must be at least eight.  The maximum stack 
    depth for program matrices is defined by the 
    MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB and must be at least 1.


    3.11.8  Required Fragment Program State 

    The state required to support program objects of all targets 
    consists of:

      an integer for the program error position, initially -1;

      an array of ubytes for the program error string, initially empty;

      and the state that must be maintained to indicate which integers 
      are currently in use as program object names.

    The state required to support the fragment program target consists 
    of:

      a bit indicating whether or not fragment program mode is enabled, 
      initially disabled;

      a set of MAX_PROGRAM_ENV_PARAMETERS_ARB four-component floating-
      point program environment parameters, initially set to (0,0,0,0);

      an unsigned integer naming the currently bound fragment program, 
      initially zero;

    The state required for each fragment program object consists of:

      an unsigned integer indicating the program object name;

      an array of type ubyte containing the program string, initially 
      empty;

      an unsigned integer holding the length of the program string, 
      initially zero;

      an enum indicating the program string format, initially
      PROGRAM_FORMAT_ASCII_ARB;

      a bit indicating whether or not the program exceeds the native 
      limits;

      six unsigned integers holding the number of instruction (ALU,
      texture, and total), texture indirection, temporary variable, and 
      program parameter binding resources used by the program, initially 
      all zero;

      six unsigned integers holding the number of native instruction 
      (ALU, texture, and total), texture indirection, temporary 
      variable, and program parameter binding resources used by the 
      program, initially all zero;

      and a set of MAX_PROGRAM_LOCAL_PARAMETERS_ARB four-component 
      floating-point program local parameters, initially set to 
      (0,0,0,0).

    Initially, no fragment program objects exist.